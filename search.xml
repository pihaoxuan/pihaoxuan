<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java和算法</title>
    <url>/2023/05/04/20230504/</url>
    <content><![CDATA[<h1 id="纯试手写第一篇文章"><a href="#纯试手写第一篇文章" class="headerlink" title="纯试手写第一篇文章"></a>纯试手写第一篇文章</h1><span id="more"></span>

<h3 id="上午写java实验——内部类和自定义类实验"><a href="#上午写java实验——内部类和自定义类实验" class="headerlink" title="上午写java实验——内部类和自定义类实验"></a>上午写java实验——内部类和自定义类实验</h3><p>注意到了一个细节，try范围内的代码是只要有异常抛出，就不会执行下去了，直接跳转到catch，后面也不会跳回去，除非有while循环，才可以循环执行try范围内的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reald = Double.parseDouble(real);</span><br><span class="line">    virtuald = Double.parseDouble(virtual);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;格式不对，请重新输入:&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码如果 real 转换成 reald ，那么直接跳转到第一个 catch ，之后的 virtual 转换成 virtuald 和  break 不会发生。</p>
<p>如果需要无条件执行一些代码，则需要使用关键字 finally。例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reald = Double.parseDouble(real);</span><br><span class="line">    virtuald = Double.parseDouble(virtual);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;格式不对，请重新输入:&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码若输入 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ff</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>即将 ff 和 1 转型为 double 类型，显然，ff 不能转型为 double 类型，因此捕获异常，直接跳转到第 6 行，其中第 4 行的 break 并不会执行，但是第 10 行的 println 确执行了。</p>
<h6 id="finally-关键字只有在退出虚拟机的时候才会被中断，否则不会中断。"><a href="#finally-关键字只有在退出虚拟机的时候才会被中断，否则不会中断。" class="headerlink" title="finally 关键字只有在退出虚拟机的时候才会被中断，否则不会中断。"></a>finally 关键字只有在退出虚拟机的时候才会被中断，否则不会中断。</h6><p>执行代码结果如下图</p>
<p><img src="/2023/05/04/20230504/20230504_01.jpg" alt="20230504_01"></p>
<h3 id="算法设计与分析作业-3"><a href="#算法设计与分析作业-3" class="headerlink" title="算法设计与分析作业  3"></a>算法设计与分析作业  3</h3><p>晚上写了一下 算法设计与分析作业 3</p>
<p>求最长不下降序列的代码</p>
<p>例如：</p>
<p>在以下数组中，求最长不下降序列。其结果就是  1，2，6，9</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">9</span>，<span class="number">-9</span>，<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果只有一个数字，那么最长不下降序列就是它本身，即记第一个元素为1（即在dp数组的对应位置中记为1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果接下来的元素值比前一个元素大，且dp值小于或等于前一个元素的dp值+1，那么这个元素的dp值+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//因为2&gt;1且2的dp值（也就是1）等于1的dp值，所以2的dp值可以+1</span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//以此类推</span></span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//第三个数字是6，</span></span><br><span class="line">dp[<span class="number">4</span>] = <span class="number">3</span>;<span class="comment">//因为6&lt;4,只能从2的dp上+1</span></span><br><span class="line">dp[<span class="number">5</span>] = <span class="number">4</span>;<span class="comment">//不论从6的dp值算还是从4的dp值算，都是4</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure>

<p>具体代码实现如下（cout出来的只是一个数字，可以修改，但是核心思想相同）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dp[MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[j] &amp;&amp; (dp[j] + <span class="number">1</span>) &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>开始接触编译</title>
    <url>/2023/05/05/20230505/</url>
    <content><![CDATA[<h1 id="编译学习"><a href="#编译学习" class="headerlink" title="编译学习"></a>编译学习</h1><span id="more"></span>

<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>编译器是将源程序通过一定的步骤转成目标程序。目标程序可以接收用户的输入，通过内部代码的加工，计算得出结果后输出。</p>
<p>解释器是逐句执行源程序。编译器是整个文件一块编译，因此，编译器比解释器快，但是出错率高；解释器的错误诊断效果好于编译器，但是速度比编译器慢。</p>
<blockquote>
<p>在把用户输入映射成为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而，解释器的错误诊断效果通常比编译器好，因为它逐个语句地执行源程序。——《编译原理》（第二版）</p>
</blockquote>
<h4 id="Java语言的处理"><a href="#Java语言的处理" class="headerlink" title="Java语言的处理"></a>Java语言的处理</h4><p>Java语言在机器内部处理时，是将编译和解释过程结合起来执行的。Java的运行环境是JDK虚拟机。Java源程序通过编译形成<strong>字节码</strong>，字节码再通过虚拟机进行解释和执行。</p>
<p>形成字节码，Java源程序就可以在不同机器上执行，因为字节码可以通过网络在机器之间传播。</p>
<h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>一个源程序可能会被分成多个模块进行存储，放在独立的文件中。有时，<strong>预处理器</strong>独立把源程序合并在一起；同时，预处理器还负责将宏转换为源语言的语句.</p>
<p>经过预处理后的源程序作为输入传递给编译器。编译器可能会把这些编译之后输出一个汇编语言的程序：<strong>因为汇编语言比较容易输出和调试</strong>，然后，汇编语言由<strong>汇编器</strong>处理，并生成<strong>可重定向</strong>的机器代码。</p>
<p>大型程序经常被分成多个部分进行编译，因此，可重定向的机器代码有必要和其他可重定向的目标文件以及库文件连接到一起，形成真正的在机器上运行的代码。而<strong>链接器</strong>能够解决外部内存地址问题。最后，<strong>加载器</strong>把所有可执行目标文件放到内存中执行。</p>
<h4 id="编译器：将源程序映射成语义上等价的目标程序"><a href="#编译器：将源程序映射成语义上等价的目标程序" class="headerlink" title="编译器：将源程序映射成语义上等价的目标程序"></a>编译器：将源程序映射成语义上等价的目标程序</h4><p>这个映射过程可以分为<strong>分析部分</strong>和<strong>综合部分</strong></p>
<p>分析部分：将报错信息（报错信息在符号表中）和代码的中间形式一起发送给综合部分。</p>
<p>综合部分：之后再谈。</p>
<h4 id="一个编译器的各个步骤"><a href="#一个编译器的各个步骤" class="headerlink" title="一个编译器的各个步骤"></a>一个编译器的各个步骤</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符流-&gt;(词法分析器)-&gt;符号流-&gt;(语法分析)-&gt;语法树-&gt;(语义分析)-&gt;语法树-&gt;(中间代码生成器)-&gt;中间表示形式-&gt;(机器无关代码优化器)-&gt;中间表示形式-&gt;(代码生成器)-&gt;目标机器语言-&gt;(机器相关代码优化器)-&gt;目标机器语言</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以上括号内的内容是编译器各个功能块，无括号内容是输入输出流。</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>1、读入字符流，组织成有意义的<strong>词素</strong></p>
<p>2、对于每个词素，输出<strong>词法单元（token）</strong>&lt;token-name.attribute-value&gt;</p>
<p>​	例如：a &#x3D;  b + c * 30  可以被词法分析成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;id,<span class="number">1</span>&gt;&lt;=&gt;&lt;id,<span class="number">2</span>&gt;&lt;+&gt;&lt;id,<span class="number">3</span>&gt;&lt;*&gt;&lt;<span class="number">30</span>&gt;</span><br></pre></td></tr></table></figure>

<p>原表达式中的空格会被忽略，变量a,b,c，运算符&#x3D;，+，*以及数字30都是词素。</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析用词法分析生成的各个词法单元的第一个分量来创建树形的中间表示，常用的表示方法是语法树，树中的每一个父节点是运算符，它的左右子节点就是进行该运算的运算分量。</p>
<p>上述例子的树形语法表示如下图：</p>
<p><img src="/2023/05/05/20230505/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.jpg" alt="语法分析"></p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>接上篇</title>
    <url>/2023/05/06/20230506/</url>
    <content><![CDATA[<h2 id="今天学的有点散乱"><a href="#今天学的有点散乱" class="headerlink" title="今天学的有点散乱"></a>今天学的有点散乱</h2><span id="more"></span>

<p>上一篇文章：<a href="/2023/05/05/20230505/" title="开始接触编译">开始接触编译</a></p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>即使用语法树和符号表，检查源程序是否和语言定义的语义一致，同时收集类型信息，将它们放在语法树或者符号表中，后面的中间代码生成中会用到。</p>
<p>同时，在语法树中，自动类型转换可以作为一个单独的节点表示，如下图</p>
<p><img src="/2023/05/06/20230506/cast.jpg" alt="cast"></p>
<p>inttofloat 表示把一个整型转换成一个浮点型。当上述（上篇文章）中的a，b，c都是浮点型时，30必须转换成浮点型才能和它们进行运算，因此发生了自动类型转换。且从低精度到高精度的转换是自然的。</p>
<h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><p>其实，上述文章中一直在讲的<strong>语法树</strong>已经是一种中间代码了。</p>
<p>中间代码需要满足两点：①<strong>易于生成</strong>     ②<strong>易于被翻译成目标机器的语言</strong></p>
<p>例如<strong>三地址代码</strong></p>
<p>上述表达式<strong>a &#x3D; b + c * 30</strong>可以表示为</p>
<p><code>code1.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = inttofloat(30)</span><br><span class="line">t2 = id3 * t1</span><br><span class="line">t3 = id2 + t2</span><br><span class="line">id1 = t3</span><br></pre></td></tr></table></figure>

<p>上述代码块就是三地址代码。</p>
<p>三地址代码有以下要求：①<strong>赋值指令右侧最多只能有一个运算符</strong>（为了保证运算顺序）；②<strong>编译器应该生成一个临时变量名存放三地址指令计算得到的值</strong>（例如t1,t2,t3）;③<strong>有些三地址代码的运算分量少于三个</strong>（例如上述代码块第1行和第4行）.</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>机器无关代码的优化，实质上就是改进中间代码，从而可以生成更好的目标代码（更好意味着执行更快或者功耗更小等等）</p>
<p>比如，上面的三地址代码第一行，可以在编译的时候直接用<strong>30.0</strong>替换<strong>30</strong>，从而避免进行转型运算，中间步骤也可以优化，具体如下</p>
<p><code>code1.2</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = id3 * 30.0</span><br><span class="line">id1 = id2 + t1</span><br></pre></td></tr></table></figure>

<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>即生成目标机器的语言。</p>
<p>中间代码作为代码生成器的输入，映射到目标语言。如果目标机器的目标语言是机器代码，那么就需要合理分配寄存器以存放变量的值。</p>
<p>例如，code1.2 可以被翻译成如下形式</p>
<p><code>code1.3</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDF R2,id3</span><br><span class="line">MULF R2,R2,#30.0</span><br><span class="line">LDF R1,id2</span><br><span class="line">ADDF R1,R2</span><br><span class="line">STF id1,R1</span><br></pre></td></tr></table></figure>

<p><strong>自行理解</strong></p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p><strong>符号表是一种数据结构</strong>，可以存储变量的各个属性，例如变量的存储分配，变量类型，变量的作用域等等。</p>
<h4 id="趟"><a href="#趟" class="headerlink" title="趟"></a>趟</h4><p>可以将多个步骤组合成一趟。例如前端步骤中的词法分析，语法分析，语义分析以及中间代码生成可以被组合成一趟，而代码优化可以作为一个可选择的趟。还可以有一个为特定目标机器生成代码的后端趟。</p>
<p>可以有不同的前端趟和某个固定的机器后端结合，实现一台机器可以编译多种语言</p>
<p>也可以固定的前端趟和不同的机器后端结合，实现同一语言不同机器编译</p>
<h4 id="编译器构造工具"><a href="#编译器构造工具" class="headerlink" title="编译器构造工具"></a>编译器构造工具</h4><p>顾名思义，就是做编译器的东西</p>
<p>1）语法分析器的生成器：根据某一规则，生成相应的语法分析器</p>
<p>2）扫描器的生成器：根据某一规则，生成相应的扫描器（扫描器也即词法分析器）</p>
<p>3）语法制导的翻译引擎：生成一组用于遍历语法树并生成中间代码的例程（没大懂，抄书的）</p>
<p>4）代码生成器的生成器：根据某些<strong>如何把中间语言翻译成目标机器语言</strong>的规则，生成代码</p>
<p>5）数据流分析引擎：收集数据流信息，即，程序的值如何从程序的一个部分流向另一个部分，可以简单的理解为，函数传参。</p>
<p>6）编译器构造工具集：构造编译器工具的集合      <strong>纯纯废话了</strong></p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>20230509（混账版）</title>
    <url>/2023/05/09/20230509/</url>
    <content><![CDATA[<h1 id="混账版"><a href="#混账版" class="headerlink" title="混账版"></a>混账版</h1><span id="more"></span>

<p>昨天没写，今天也混账</p>
<p>都是水！！</p>
<p>准备签证资料，烦得很</p>
<p>装好了Ubuntu20.04版本，如果有些button显示不全，就是分辨率的问题，如果输入法奇怪，去设置里面吧全屏和双拼换一下，换成微软的输入法，其它都还可以。Ubuntu比Windows好用。</p>
<p>操作系统，恶补</p>
<p>无</p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>龙书的散件</title>
    <url>/2023/05/07/20230507/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="龙书的皮屑"><a href="#龙书的皮屑" class="headerlink" title="龙书的皮屑"></a>龙书的皮屑</h1><span id="more"></span>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>挺有意思的。</p>
<h5 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h5><p>在C语言中，代码的作用域是通过一对花括号**{}<strong>来决定的，一个花括号包围起来的部分叫做一个</strong>块<strong>而且C语言支持块的嵌套，这种嵌套特性叫做</strong>块结构**。</p>
<p>例如下面的代码</p>
<p><code>code scope1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a  =<span class="number">3</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在任何编译器上执行，执行结果一定是如下图所示</p>
<img src="/2023/05/07/20230507/scope.jpg" alt="scope" style="zoom:150%;">

<p>第11行中的 a 是第10行的 a ，并且，观察第九行和第十位行，得知，a &#x3D; 3只在这个区域有效，而在此之前，观察第八行 int b &#x3D; 2，也只在第七行的 { 和第十八行的 } 之间有效。因此，最后一次的输出结果正是最初定义的数值。以此类推也就不难理解作用域了。</p>
<p>例如Java语言，定义了关键字来表示一个或者一些成员变量的作用域。其中<strong>private</strong>表示私有的，即只有该类能够访问该成员变量；<strong>protected</strong>表示被保护的，即该类及其子类可以访问；<strong>public</strong>表示公共的，即不论在程序的哪个部分都可以访问。</p>
<h5 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h5><p>如果说例如<code>code scope1</code>中的代码，编译器在编译阶段就可以确定某个变量的值，那么可以将这些变狼的作用域叫做静态作用域。那么相应的还有动态作用域。即程序在编译时刻并不知道这个变量到底什么时候有，或者在这个地方代表什么值。</p>
<p><code>code scope2</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a (x + 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x =<span class="number">1</span>;  </span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码块<code>code scope2</code>中，先宏定义了一个a，且值等于x+1，但是并不知道x在哪，x的值是多少。</p>
<p>在函数f1中，重新定义了x &#x3D; 1，因此，x &#x3D; 1作用域只在f1中有效，所以输出结果是____;在函数f2中，并没有重新定义x，因此x还是全局定义时的2，所以输出结果是____。</p>
<h4 id="函数传参机制"><a href="#函数传参机制" class="headerlink" title="函数传参机制"></a>函数传参机制</h4><p>函数传参大多数无非使用两种机制<strong>值调用</strong>和<strong>引用调用</strong>。涉及到<strong>形式参数（形参）</strong>和<strong>实在参数（实参）</strong></p>
<h5 id="值调用"><a href="#值调用" class="headerlink" title="值调用"></a>值调用</h5><p>在调用时，内部处理对实参进行拷贝，将拷贝的值放在函数中进行处理，但是在主函数中，依旧是原来的值。可以简单地理解为，对实参的<strong>盗版</strong>进行了一系列处理，但是对正版没做出任何处理，在实际使用中依旧是使用正版。</p>
<p>但是在C语言中，我们可以传一个变量的指针进函数，虽然也是对传进去的值进行拷贝后处理，但是传原来的指针和拷贝后的指针都指向同一个内存区域，即同一个值，如果对该值做出处理。那么原来的值也会相应改变。</p>
<p>还有一种方法，我们可以将值return出来，但是，其实也不改变之前按变量的值，只是return出来的值变了。</p>
<p><code>code3</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x ++;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x ++;</span><br><span class="line">    <span class="keyword">return</span> x;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f1</span>(x);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f2</span>(x)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">f3</span>(&amp;x);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h5><p>引用调用其实就是将需要调用的参数的地址传到相应函数进行处理。</p>
<p>但是，如果调用的实参时一个表达式，那么，编译器会先将表达式的值计算出来，然后存在自己的位置（另外的位置），改变形参会改变这个位置上的值，但是对调用者的数据没有影响。</p>
<p>友链：<a href="https://blog.csdn.net/m0_37618340/article/details/81070416#:~:text=%E6%8C%89">按值调用和按引用调用</a></p>
<h4 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h4><p>①声明和定义：声明式告诉我们事物的类型，而定义告诉我们它的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;<span class="comment">//声明</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<p>②别名：如果p和q指向同一位置，那么p和q实质上是一样的，则称p是q的别名，或者 q是p的别名。他们之间任一改变都会影响另一个的改变。</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言函数解释</title>
    <url>/2023/05/22/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>关于C语言中一些系统定义的解释</p>
<span id="more"></span>

<h3 id="perror-char"><a href="#perror-char" class="headerlink" title="perror( char )"></a>perror( char )</h3><blockquote>
<p>作用：输出错误信息</p>
<p>参数解释：传入字符串，例如<code>perror(&quot;upper&quot;)</code></p>
<p>标准输出：<code>upper: error message</code> 其中error message 是系统定义的错误信息</p>
<p>在写代码是可以适当使用该函数，用来调试程序，函数会指出错误原因</p>
</blockquote>
<h3 id="stderr"><a href="#stderr" class="headerlink" title="stderr"></a>stderr</h3><blockquote>
<p>作用：输出文件处理时候的错误信息</p>
<p>注意：这个不是函数，而是一个指针，类型为<code>FILE*</code>，作为<code>fprintf</code>中的第一个参数使用，后接错误信息</p>
<p><code>code01</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> err_code = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error occurred, error code is %d\n&quot;</span>, err_code);</span><br><span class="line">  <span class="keyword">return</span> err_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该参数只处理文件操作错误的信息</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>chatgpt镜像</title>
    <url>/2023/05/06/chatgpt%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9782d8a92576679095f661fb9c51cdac7e93473c607ad205d54ced12b48973bb">4630436162ade97ba2718b7d0c4b3b63492810e13ad85be96e947ea4cb65291430a49bb22ad32d84514670596647149d7c92fe70cc097ce99432d6eddecce600fad1be98eebf5ebc7267d7570a201229361d4601678f68284fac1faa62f257283de9c1d84d76d52a5d274a0ee68cafbfb91d67d40a478ff73a1ad594d725f4da9498f1f68e505b55bf44b90b8ef5feae4de5a06f4d567e6c2d194242617d2bed2a2b0d60b841753c3e1dcc3f00300b27691e5ffc477dfa6bcd8f8cc6bce4d54cae1b1ca80b7220554bf03c25e69fb7a5073c4ba05eb2bd3c9e0f8eec510d1acecd510767dc145016e3a07d486ab66fb5493658d1c5ffc1b1fbbf8ce6c9ffb8a5e3e4d0e42004203d5db442eb2f7206fa4a31054912f2428aba3c5b62bbdf601b83c3e3434d481590219e979cfc12f1c02756d30174bccf981abc1edf19f8725f0bb920ad5eaca2ad404607adde4dee9aebb3be366203a4393a2b324c439a6e57407dc13a9b1ae9c375123f1645ea6268a5215d0fcc6dfc46d951222ed405e44e49e78104be5dd5674ca8def738053863480150529d69b87a45a8788ba517ecfd1ab5ac8e38e2741ac0f8c4383df5930be5bb8bcc284aa9aac5e434770a032dee240dc6549e8e800afd9954fd51663dcd15b735954903f2036daf0e434049f27dba3f3d143b614545f26acf5d161b6ccc96d5f471bda843facdf9ba37f0a02fde454aa6af0c81eec42693e0feae575e381303f41e1ed50dbc4fad93738baab316c2ada34affbfc44f9265fe4e0a85cf35b543bce952ed93f1d87af67d6b3617008373a081675e1c3d05747eff2051b5cb316c740d36132a263b302ce245f0079f2a23384a442ec7a4746039bea493700ae105d1b9f286e7ed9a8c670c9b377487e9193531853be2eb3499f7e64f5f415506ab41cea87d217068baf64dfd137e738c94050e3c44a040dc385eca0d360c3c88cb447d783ccbe0b46866f318d459677869888c33e16105042f9892b3897d8c16b92585978201d35cce7740821d2b915aa94d49735f7be058242dad461b4892442830e6344be389c0d965690e9a2d30f6b1c07db59756f3210947333da4e4bbf96cf05c3f7d41f0be38ba0dac374c4357393fa84b8a3da4acae8b698c67dedc8bba49db46fdcf0fda5203c83c0c6591f48790a4bd4c75168b0dea6117b176f83a9f0b59e68e3fec8f06c4ffa262028c1efcbacad7d0262b3151a45326fcb28b4b804c69333257e7aef59ee7fd732ca3cbf92e36cef2ed8624318fea85f562cf243988c9b90d5a503f004a8a8e88a96699285f7a54509ac44f289acf346a35b95444bb2621e0eff711f716d16618a370f295378f33307f77dc891a67db10c20d4debae8a802dfaf520412b0828d0aa017fde902b4d2851b83d35d9579d2b99a8d1caf2b6fd9544ff7f6c66af89e2e8972fe00693b388a24173bf42d2838f726bb97bec2a11e25ff8b3fd3668911c3c72c8db6030a98b67a313dc19ba6fed53f890a8c57617b7f07373b746a0bdd0e37fa0f7bcccaa93d601aa11d11cf4377628e19a975e2f40e0129629e90c737cf1d888677884a00a3ce04029b107a5dbf3ee711ff17ed73330d8f0e4d172ae40d6a5c4de55c8ede96ca5cf5eee9074c0594608bc128e59707ed59d3271bd2c9a0ba8b9a18082ffebe4c148bf1689c0a8e228e4d9d39a6e9c2b9fac311018a86da11b61c22c61a00100c5241ca8a5b2574382cea775aa17052d35ec6fe37d2389ce094a2da54a03c96112553f7c26d380d7f52f418f02298da6dfe829defd46dc1a0c5d31cbf8c28857fab294bcb458464e0586c26126cd61b98cf789848fe2783c811138feaffee580d032ce932cf7931540e20199ecfcd59b186fa1759ecd082ddb353226c2cea2404c467bd3ce30c8eeed473928ff4f27acbedfe26ce3ed4ecd4dc87f2d296602775c6733d7dd14ca6ae213845ffecd87c1bf45a0bb5263dbd20e8cd061a96f05aba4e770f963966d5aebc1ad14129f329d75cf262a71f100473e1b6ec3af60b283c033c5956dc965bbb9b90a076efb439eb604fe93579678595600dde7ac0d76551b4788633a841a6c3a230141187e6794460107230a69e017b0d35617a68002a3ccb06e183fb33a0b21e8e5783ddbed84e32b7f6c5883a98222583c24d03ceddec98873eada1fd0b61cd3f10f2c818ad40d9622f37c653facfff2824f2fca83d0c6ca07876339ed128c94faf29242101a79193c32304ebcaa1e3c5d865341ca8bbc0dab90f5f459c0bf0b0c50d5c0e2edbd79b0fe25e36c155cf2ff6f91814270f2e4d54950f7a249a919fd4cdea45b653e53676f6ac402e0c794b411023ae460a41edcfd24698ffcbf92e5c30cc5c6cdbf211fb64e74636d6de56bbdee88920fe87dfb59f534ddd98c5aac8aba9fb1243e1d0ff47a7fd4172cf1b0a9efd8f3af94354fa58da2deef458ba4ce6ad1778a93b8d7718f779ac3189c6be49e0edc2538082837f1f090beda0b0b3362943213f5c1aa9f6bbe28914b086988503ce1603c3627260c10f575a3481b31c630a94499da2c8f536aca35845bd4e50c9adfd6d32019502dd15d8e022e1d08e58ed17016cdab85062bb944b126c3325035c7656866e7a43acdece04acb3c047ec39d3f7d79eb3a1252153ebcb5b634b83527a7c5ee83b16216cd933eba78ff702b7762c46e27d3a4b3b06d53f55468200855f196b55b950ef8263cfa7369ad6a7dadcbdbdfd47dfc8262df36593c57a5134b41c6f33893f7cd6be779e421a752db43699113e88116d56882720ffec4ce60ed4c9d3527805e68e7531116121a59bd7127bb19904ff5dda98900b04049158b7b2f9e450371fc4d2997f21a09c1e9588eb081d1c569425269f34e6ae130af638305ce0eb2f647f15ac7c4d8ab16fbf98dcd705b8e2df417f6d8d8e7d4dd7516fba0b1b112d36548eed5378e85f555f5899038608b1bfa1dc384f15e22f8cad929fd8ffc7d94ac5db009d124ef6d3f13a88451b0a04f1ccf9a677ea6c92ef75c9ca7854756f82dbc6ae1495ea7acfc336c3dbd60714e2d1bebc5607f29bcbe4cba62796521c06cd44c5baefb7c634444961b23bc9900bbb7017a2340fde7bff87370c4e984a5f86f2b3921c256ea0644bbf355b4c55ee187c051f8ffa19dd7fee0643362ae12f2736e4b12ce249d835603855b8e678daae361e04e1810089ffc50099efeb7fc1643b335d94f1edb93a158f30e77192067f3416b8a3f074e2d54e7e1c6a263148aa9aa03702493961c01b5a812b2a0adba7e137625ef1e0e59098c834bb2f07a9f4210ece8a2a88e2193323edb0bd52f4e4d1a7beff52477de749639dd9015b15531490d2da3fc2bffada262ab853f9a3bc2f4c989658baa2ec803e3b0956fcf6a922e37ec1a40901e69107c1d57bae20bea6cc22bea30eed6915e33721527b15ba20b483cd1b939b00f6b59159a6e1be5bb327c7c7d8af2d4d5521b49bd0364421674d4bb7af2a9e0a172cb09bfde0e88fd6f56e3d6f41e0c56a304ae248bb06c1fca9c50eced2730c58d89c104d74acc1eef4c1247d70f916075d11edcfbed986e250375cd43743a20846d891a333dd4217240aab96ce0d40012202698b748860dadd450ac5d7044067c5c993aa7e7e26da28b653b8caa34ef2df95817cc02a7cc452b169bcc869789aa7ee902df5d35798310955fb0fa6d79a5cd25dc178c643d39b1d04118891cb15fe2576c6a55a480694588e57364fad22033e9ec0be0516d72d48c32e29eef23ecea53f9cdf90da7bb5d42abb0ffbd1b09dd8f001d50d1fca05684c9749bebd9f0ab03d0d9cf8cf1bc42b2</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>chatgpt</category>
      </categories>
      <tags>
        <tag>chatgpt镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>注册GPT</title>
    <url>/2023/05/06/%E6%B3%A8%E5%86%8CGPT/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d25b01bf574e67f9853e1cb6d712a7b24b4c9d509ba554a4eb9098f963d23918">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186df8f2756c43971a118e851709297bccf155b395cf773d208ccb8a172a2b7fdb59343265437c52df6e148cfb73903a85bd7775e486d959713845b7c0d63c0c2daa8fb39a105bea6d9085ea460c8f9e730fb6331b31088000e2538cabf7de26b07fce0a9b71381b480b63b934406caa07ffa2ab87798be35f5fbdbfa8907a37509422eb7724fc428acb5a0b8770bd3968ff160a13472fb09413da2cc4af69aeafdd7db9c8d4c6e7242aa01610a7ad737b86629be436cb906f1ff3bc49db88ffc4efaf3c50f147484826af90623732b10cea9e6fb89552ab84306df23712a88057cac6409fe2de37cd8568cc00573d7d1a15e5560d500aa0007b54cce85c64697aef818d4dc97ade896b89973f473430f46daa7a27749373c43a175a1f7e398d55dabaa30d4d4372fb2627c73052a4568f071038f010283bd9749c96b03cf3cb4a5bb88facf1dd6343a8b8250e995d4758d97ddbc79b858ee9d1980c205937a1ae4328ad1f65cf96b6c071283685057fd23301687882d3a8d941df173eb5e6ca1dc1cfca66f8b0e808799f3ff2525bfa2c3f322d51dfa3331056403a804186eafa4893a52175da8ea68abb48bbf727b08e18b4eb6b3ebf86d23eed107e9d0daaf926badb1db3345071d9b88c8bfc536731e990be76dc058a392b75aa7d67c6fbe46be802aa8b156102cfe8be18f762f3630bc3552e194bd4958a84c05ae4711e6bc07fb34c9eaf2012daeb74c85aed326ba7d7c3cefb52498e6f76dcf2048ded3df12caf6ade1677a8cd745f776bb6e5e9e579665c6c2ef09bd9b00a8b27069695014531bd325a3370ee0c64088a044daa0eb9d711c25fd5a44de3bd56ec6beb2fe5862173bc2c720bea8fda58482670cf265856c6081ec0200032ff26a99a16c6004ce3631aaf3a5847c283e615eb32aef4ea27c18633a7550877630dd522a42542ea549e27ceb85bbc2e10f3618acefdb70f29aa551b6bcef47d7896c1ac7d09f0f62a401f11b665a0cc0ceb16e70d2640d5d318b1256af17d717a994882a2bed9d040a90941a09d9ae3ca5419bd93db80aacff88300316ea07339faddbec4fa0e7f527ea0151bef395d40919b3131c3bc207554050741958f632dc856cdae62a7ef10d5a63f2c8f42e6480608c6e0bc456e76443594115ef13d44c677e296ec01c67482ff9d623c5e410a2245305cc8fcf34142671decb0b4633d36bff888ff1df30d2711da3610643ede32af2a750f9ffd6970c8e5b29dd86849a38d1af2e8e3558893f9395b5e8212fc437ae89987e9daf2c7ea7b090e125ed70045ccd707ba73cc519e69bb728517623c1a54895c036984a0b847fbb927c9d2a86795b80146e2141fc343ba684ba123a91b8a1779742cdc31bb1b1045facc23aeab84035bb49d8b4d0d760059f764273004ef4ca70e69fbb6e3b804add69ab03550e6b5d33cd16571099d8e1c940dccc97756ffbbd8c708aaecb81c7bed97dce344ae9dcd50b6a793ac32457bd2ab9e6aaa81ead4faface08f0ab518cd342386074c879c42dd2bee6404287f6111b140280739a9ecc95d77b9639c5112cff7dadd7642fb50d089f8f0c2af996313bcb22f7d09b18927d90142e0308f3649bcf580c42cd6384a904b4d0d4ba1410af6d7d8fe2540751ad23f42959618675052086075c141233a0eda8478868186a482c2f6135e84eaff76505689f6dd2bd26befca3f6eb352ec25f9f1f5d3a8b95cfa60612ec0078e4a8af0f72291ad220c99872537c44a6ec60fe3be974d26d7f0d332671dbf1bf40737cb11769e27e1e50d34dab797f4ceac4264ff7798a871b646edafbf1653bcfacfb36b5f4531aa2dc09b786b88a800f985a1c776a88713c3bd26d8929a3d6182ea7559914d6d91fa24d1b7c8876589183c8dc8661e5b32d748d04043b5a425b28e6b405f24b0e80e233c699252f12e6bdddf9a662fce9f5c41f821d119c0592df8370298a75ba3388de8efc5e9d1fde67efa8fa754c3cfcb217b86874fc0079acd8e6b78609ea44822d8e0e2eb7068ca8fb1d99c3554b2c85f570a8232b895d73c6404ff43d73848a5ec75fa118e1bfc483ac108090253a3be155a2d1b2b3e0b57c17a41e077ea38a4c97dd22c95594f16ba9caf3f3a8cd6e5e2eeace520fc2abc4c0aa4eeb993aac66fbcbce2306033ca1f437046def8156c1a7a28d165be106ad7cb85f067a143bc3cea35a8eafb825a36dff98e0bfe3ff977fecd87a04cd861fbb072fae288be6cafd30cd78ab0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>chatgpt</category>
      </categories>
      <tags>
        <tag>注册ChatGpt</tag>
      </tags>
  </entry>
  <entry>
    <title>算法实验1</title>
    <url>/2023/05/19/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="57662087585af36386bfa6acd4c30948c870587f7e9d1f80b7da7ab54df26e8d">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f584592818630393e0b8653e49ecdd4b91fa719f352c0f69e7096c923ec34e9d517c86453c5c701b061817eb8a943a3a34fc7163f9f674c1e6b2d90bf1c8367b2890d71f2eb230990aead5236d38a1a5ee5116647554167d1fe07be69d1a3ae8f6166191a1f2165d13cd8d2fcb0fb2af2beb69b0d21346b1358c576e961b888b3335425dd1eb123b5160f186bcfab0913aa414453bc136f532f0871293d62234edc8f4e1161abddae52cd02adcd36becc460936a151524e97020539284c63f4427e8f1761ccb48bf9ac6e965837271bd233823e007b7cae29006296833cec58f5f93a567e29056687c00cc5d6c98a240e64129a644c360ff590f74bcd3a232d48e65a871d04b4a8dc76d5433ca9d2f2f2036a09edc6a82da588c2c4e43395583661bc2297e504734bfbcf2366413475c13dcac54524330c54dd65207961265a71bb059f870d16e39f519ecc42990405da82a5f7f50c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
  </entry>
  <entry>
    <title>算法实验2</title>
    <url>/2023/05/19/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ef8e8e342ce221d3a5165a0dfbbf5229b1996bc52b5c9a174386ada9823c1d88">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f58459281865faa224400e4742cafdcfd8368963d3c5ef31b995c0ee49cc47a72918c4f894f5e881322f87527fcfe58b82eeac4ec80883f8a1422c5ebc4557f74f7f7369ef6d3a892b2bfc2912a3d1105f24c629410c3d28fe54e943aece519959ef401fd14c22530105764f6c3f3f8b31f6aed62b7ebb5c4df787c200b9dbdff57e4399a945a7ee1feab777a758ddc5621ce4c7b92c18a1329f2bea97f29250c04c210d07498af532db310d2a28c3e9d4fea01d4299059ecc269adc131582af19164e4384afbb1a05aa1390b8c1d854ffd6b6a3934d0882d18e6f1d6dac2a8f5b16d498c39455e5d62ec604ff802995fa6ff3ed34b20fdeca559db25966ee32530812f84edff36d71eb05f409d21c4bbc3d77d4ec67ac720f55a8bdfbff697b62b2d7d53186b3273a078da8fa1a0ed59134d733dedfe57f8507589761094fc497ffdfcef0722ec5d43944699b5ba925f98a6b60b169ff3cfe892d7844edb83475c94b89894c3a5587d9494bd0b344eac24a2fa6a266d9da464b73cafd3dc49f0446ea594df6c21a0e4038bf4c93d2f62ed44b55fa7091bba286c7fec69df1db6b239307230e0ca5ac1075781aeecaeb0598e2183c7388e299c67076a085ac8c94fc810fd9d67e0f5d6c365fd36cd419f53e84b6d9f0921283100c7d7396c36c5a7cbed656c7516c728e860cf3ed35508c9478772ee49f5fb560e2351d1a0a9ca112a150c1c7decdb51f0eebaef044d3755c1171b2f96381240bc7811ef15af36b6743e8109d7d59573c19984719a34ad19f9ada92fdac587286eb6aacd804c393f923335e5de9db0e26908b49396e75ab8a0b774cccc270f5bfb2c695557ac2215f7b07174204b58aa3cbe671c1328f5800e3c24e5b62e2a83746ff2e1a775b49bd46934f4077693f05030c8d153416388d9113bdc17677dd282b9a22e9b9c811f2972de1563f1584adf88878b2a3e05c90eecd821e60e58e6436f92cbf89b37c9cd698fd0a32552a4db32d1322d8b3aa38ac22c90d228976c7b99dda699edad4975e36a2ddbafb14ce0513e6f50b61ef131aa6c502b1dd8d85af7cb6d904719322f130d5e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计与分析-作业3</title>
    <url>/2023/05/04/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5a240742c121a6346598bc123b89fe68c302fd1fb5b6d3ea096735c39402afe0">4630436162ade97ba2718b7d0c4b3b63501b8b0e90dd70c68cacef77fafaa69cb655445445de2a757b2056ec9ce280fb4f205d7f6eb5d4506eb630ca932e06992a79c661e63aa74787bd4cd18ba35f0fb06d679e484e67672b2b103c73a777903a3af263a3ea0cc1e572fbc2e7f27e0b8fe1e34d8e411e783507e537d4ff1967e0fb33a9bc04f1c019dd2296e004deda8fe01437fb6f53154dc6be9dce6f7fbd55bf8720a68d61c293ebf56882f9dea122b5535b446a87ffa1ff747a31a23c8efba759e2dd08b062fa436f47e953de76c2b87c917add3ffb0739bfa6381f8f21951db7f65e98ffb5bec571f4f0462dc6e1116ffe2a5de9f25ed44d6264a4ebcc316d70911975a1e4bd1d421d97e85a9f397ef0c95cce1dfd2a41f6cf5090447d63703b79e312ae290064e31582546ce60f8e75be17c0f01facc59db5520da845dddae9720e8b64a4eaad8cdb7e7d9273b87d31264cba75ca18f3ebe170f745f7abb1ec22b151ea0dfcf9b8de1376f9c2f1071c3aa4757c8291b243d2bb5f4489f0de87a90b245ccdfebe57d4e057c980812b26f9c318f5c91972ea3ba74d233e34ecb7e4dea5e7602ef6e40dd3d7ced7bee47f7595371d53b5444aec0daa8d4bbc312471ea55e45ebbe84dc42c4f584ae7c66ecbd097f93df7ef18fc08778233d77f3cde74aa7a604955869a97d0e626b0bee922b88ba947d05bfa592162a58851339ad8929d121385426b7d46eb0f2ad2c46b97ecbf919c7dc0e7a3eeeaf70285e87f53b25268e08d4417de2001699e5bea937f706e05cb32da617c10b40de9c12557e7c9b9c324c65dd5d5aa4c29996049b0371685fe53e1771e6100577f85a170728c8204d434b865d75de13b5990675ac06990f5f6507ef3b7b4c082dd16378daee1af80e6e89c7cb2fdba6cf4dcfe694f8e28c560b330ce6d98057b3978a1fc9d8e505bd11038931d9616c5b3f6506a57da2d9fb562624e87e34ab62b24d8beaf0bae6be43d1087de867e56e269adadc712a72f9c90eaee34e7ca7be182305ce3741f72ac1dab6bb6bab70a8aa376d43251410e03390efaefdd893bd5b96a02dacea8a3e30a70a562213ca022a0caade139a8b6f9495b45d56ac7f9cdaae17446ec8a0c880e34372d140f85bdbf25914e4d4ee6d71df326fe0771b67564e83c64130c5cee5a866505c17596dac7807feb18c2ae46e7ae1b37f2f1b112bbf832c4391bd928f84176aa67bad129c51465e93f6ddb53774868e6481292033b200a39f58473afc8660848ab9a2be928c142c895dac17280af94682fc61b8a4be6155c2bea972c05f6af2cd08efe4782112139ed7c5e26cf1f559f95b1345cf8713f1f4ac33a19a10f5810778d6ba57296c28e4e31e9e44bf49f54055fec8d74b62256fdbe8552907dfceae32a38509ea90ed81bafeb9ae239c4b7ef593e00c49603602d36c08b24a6554f5540db8a1621ee6019dae4c869825fe2fbed7bca3bd7238e29434579b40350ee692dbc92b744e5e6eeeeed5e775617fbd648ba4d19de6b96b0e317d82fabbf50fadb2438e8158cb50aa5dc7f671e1d4cbc98c9506b31b62b8d02dd0219f5d9f67a9cc1694772d6bfbc47107ea6eef0503a84c848f5d4c3e75db8ed8fce0aa425714aafbfc09c28c15693894a22ccdca9b7e3253d4335d7fe719160cbaf684a57b4425ec6c36f8b1bdd433b12ab4b10afa7bb01f14419db77116af042b44387bd95d90303e998c2ee5b993438bf863d135be1a5e3b17e2374c24871b69b449d79682519f795da3a4bf1eefeaaa7e895a5289b8b1aa50fd9a68956e1130849db254a79f9e2d974fd5abe33408596282304d853aa114f9859383c265dfb17cdc16bc9ea2cad4c414a153062d7a201f54b1f04ad0505d2caf172ba205af092b43ee78aa99cc9f3ac0e1c1b46b1a1652b7e3341340d9ae42db6d6ce15215cf6f2d4b8828e6f533aec6e1d04c21c21cbf4b4f6182de9f44eaea285efbc8fff779934d6634ea476cdbf139035665380830b2e1c895c7ba27a596f1e03eab2e71ab18e1ae16a7da87226429465f5ee9166e1e8095e9bdae30b83d4b040c014864cfaf80f83acd24a2ea1cfdb3812343edb94d3f9d4fe8c142cbee58c49bfb48de6ae1c2875078dfe929506f6081670aaa0d2b5d147c9b91c2859e07b1be8349e7f321ba351184262f975ca2b5dd2be5f0f7bdc9c8ad787b84f9d6a80edb0c1c1be1513fcb0bb04202f0d11259b46e1781ae35dfbe8e30329ec77935d69a986adc66db802abe2a01be3f1c861510f5f60d04c7fb8b7f0cabd43fb41a76d54537410e657b49e8bf713b67741ef327bacc82b6640c856655fca260b1b5ab51e86c8450ded710e2163b5fda05c7bb9a8e4b504eaa7b887bf0e1f412dc8bd3a12c577dcdce1bf6239f08b8489139c7c9c6b3f3080a7a3a92b4096771a9f4f523edf8ff090c51a4c82c1191ff913ab1adc7a273de26d67b010edf5d3b5dcd04e779bc85fcf7268df1669667061f0e40c44ef6738b9089adcd7e0764caf9a9dd3147b22fd2915ae0792c953a2d03bdcc9081773f29f7713b1e9541ee0821a877edc8568e2d394c3b354b1170a01020c9908496e1265e4636eb3af1719e3d5aa91548784b6afe38d237c487ea8d443d0a7f5a0d8c9f7c69ce9a2a546afd00a317fbf2d2b6cd17c4e0e7b45764f5a650e25e7cb4ecaa190c27c5178f5793b8b5c8e952beeb596be401cd28d0537f4476414e50b5c2c08914eeb39aa5eced11399beb1ec0c387abb88b0dec54bc6be88b88f8e76d411cdd2156cf2702175c5ec9a250a500f64b069dcfb5fd048279e276ba4dcf3f3d367fd1e412bcc5301f7638b2a969363689ef54db33b5d8fe27028534122b8f359941d30793f8b76c3d8d5f2277f8e7079e2709dd82e7e74e6a6459016fe1b77bf48f18f35beeadef4b96b27c215690b14133906145eb6f40a40ddcd8a80c121476cc03408f86b601be0598d8128ece70b48122ee1ada203e23697e45e68d72220783e7179adc2835f61dbb14c9b58153074f6cba9f7bf96799d3ee8f13201fda3f4dcac711b48e616520aa6cb3fbd85058babb04b6919b844c508ab0d71437d9915aed7b5f736bc8418439f4bf5ad29eceb9067ded1529a4ae783a8bc65793dc79cde806c45bfccf4ed880ce338b4d601728ca2885bffc4c7dd7bac8e0721cdebe57cb7b5e5926143394588dd7f3657a41be624205e99454f4d2f244d1e27042a5d0abdf8e6ef9e7d2ae1a3d02196c8dac83b755c2a3aec05060ae6a08be481d183f707af4a40bd78ec031bdaf7b5e0773ae87b7933afe21ef672bce9d2a8de5c8ed28819f6dbc11ef80437ef38503c60259d7f2feb92d7dd836b3e1648b93e6e7b7554c4f6c5ef8e39abcf6c79b2a4c49d2d1325be1e87dffae8a843f0d41915201975d01dca6b306060c05e0a006fc7dfd85bb5e7b10444e23deb2c9656ff3a5e63bb6a737d3ec0e6cb3fe63cd8bb6b71ccfb4c2961ffc720dcaf27524824f6a826eb6b5bf827f6381b8c26288b00ccda8f70c97d632605d4e975dee46927f4f588e722a29fca24970bb06093b4977c575927a93a853d9d6b21967615481f47f741936a0331dc947cf13d3031e3a32087b21fd09de46507c386f0daa7b8dd663b1f65d7775fc9b38d3e37fc52ce5c1ed2d3f3dd084847f1cc0df8b49e5baaf269fed1001fe2a6a065efb4ab66e6a835b8bfc441528e20b5d7b3bc9d517b208da32a41e24a84c55911a7be43097b511fdf1221f8e8f587c63be93c4a24298d5a482f3de45454f8671e3e5a69f9e8d25e6bf0cedb1fe3b98496c2a19bd975fe2fa0dab7658667d9afad85e3dc798e0186cd1e4bd90469218e7f0480dcabb890124a5525a1dd8452c5988fc15ed144b5fa97308880242077e7fed1bd570615014a7b400fd5af545f1d696eca394f5e9861bd4e9b8dd807981d83f95b5e779eac39c4481e251f441eb1f2b943c9af5285f81f09fce090d29b2be5783a06eeb87a62a9154e78cc10f4ca3a953457a1ba999eaf80d20c331b54c505ada843ed749309714443b5e4b0a6c4a2208886090fed04e572569daf9c4144e236a8b24f6552fe6d808e8478045d33be3ea8a7b37fec2f2f1e75132419caf2510e8272fbe086752ffc41b6869dc72fb92f79281a591efc14b2926b915330950fbc6ad361f23dd3fc3147c58c8b5df08d5bfd51a0655d4b52ee516056ec1bd416b3fe05ef8ffc08e5f431bf5d4766714a906ffba1b3a778c2a075721cdb579a0553331e8d1963ada43b6c3dea1bd2f614cc87fd33a60eee1cc2e4729f27eb6017e0d68ad73792e8379bf36a50fcbe259cf76faf357ef8e6d1be669c3e814c1fe19644b5c038fec2c8f6837d1aacf80c0416bf018012523cd66a6f06d700ba4f8a603c11396b9b4b72804cf76959715e27c3a361f7d906f221f8f77bc9d124011dd7d781a3b2b90a0453e289e43fe7a8ddec9b499aabb865e607cb3179ada10075fda4b393c7d15092b566e4eeafd85d1cf54b3b05c48def525da82871a48995007b4e8d3f34858e9d5b7bd781ff7aea1544c2bbca005340a00aa3f723a851868dcf8f7f62168b9f2ab6af5694c4b108dd979a238d55617f351ad9d39ed17617e4329e8778be29decc4e02d0be4cdfb6f946af9536c7ffb16cb8354f06887ea67b3eca34c37992475fe42c41fd2f3867d21dd7a3ac96a1a7622305c76321068f1d790d1a78a2cf27687616cf49dab6b136a9d70f07a949b65b1210b664097c0df714d70732d3c1e0c07a56fa7bb218f484bd741a31f95750345bf05515b405c8dba20a657f2778efa0bc34f726ca5cc0a13bdbbe270f3147c52d8091890d69e2773b0c1618aca3bfa36ec05d4050e218c60dfed3d82b0ecdfb35ac06a7acf57ae0466d12bd90226af82947addbc3d7b1e5749be72f2b3c6f92a2df670efec7fe785a1b7a3112d074887e1e2e0c90e55f0df82c242a6a31edf44a94f2a3fe3668d54cfc254ce90693918210911b18e3cf1cfe965079a750d12d267eb39f94dec96e5035180f6d4c171f38afb37ceb0a850418f6f6decde29bcb61d9c93658dc9b05bcfee4a9323bec51d26a4397dff233f573719ef1c9ac815e0a6fdd13a3a0e30fc7597fabe0c26847fb7d0ea2dd207472f47a04950de56178f5015412579336bad7be32b07707084a7068d7c10532db959612c9795fda9a55d10ca83f21aafa23c01d7436032537b0ec3f19df632b47c7021f25040d8b5bbbf5ca3b4dc022af37c029ddebd5b811de9876a7f3b991628b9effe0a69484e4c68b5b754e70e0e286b35adf4cf4bf32678074920a150441c2158f53c46843b57fafa974c5a6de1b3a7ce926739ea187a2d50ac279c067cfc68194d10f8b0ea733f6f4e568d0bc3cf4b5e776cabd9e1ce56d11c9565c05bc7214c394e00ae5f2f4c553f9e8be1df815b3797f8ec48d2c9aa63854470c34c518c8b6e77d03172bce6a5eee1e1a65961797507f3f07d577f90fb66184b1c2f5ed9a724a345b1903632fff8a693269b6bc8c0ad1662f10151891441bfa197df158427cc8631a18ec743f3905172ba840befdac6c392282127a3210628176acb9cb0d7c7de4b52e4aa6e8beb771ca2cea4538b1363da976983efc31966606dbde54009d3614cbb09d1b1908425f6a49c124e09849310b6418e6f8091269de37580303d5a5949f0bbf75fb60858bd90d1b8ae48536b0e66e14e8d98e077b71e14fccfb56f69ca17323b74ded6560751e3a8a5e1cc8652cf4d015ebd14c320bbb36c8ee4da5608463989f144b7e004c9e90ff75953e4c69b95155d10d1898bef2593b16948d398916110b9ffcff8f2f3d4606e64c15fcd9bc32caca65901634a0f1632459234997255cdc6c24b1e2cc915c9c6518565a6d3c1b1f9e1a05bdbbdf4a1eb97c31af806dcb663a240d018f8e83f3097fa81bafbd08267c8aa70b6d48e7f835dd2b1eb6d3ef83986b2eab86fb86748b2eb7cd4c1535e16eb13d394223dde630c9be81367c6c6bedd6a110034e08e614c324efc04a65cf5a1a92abbc4f2cc4ddcde1566d3b387a8a25004eed7d2b45cd40e17502a007aa6307fed54334d054948aea8b7f2522222c37374b4ab9d2fc5a55ec40ca4b5a3b0d72b0d8d9d8e46452a537890fda36c7701ec8e56a5d9b5763de904480c589b81161af6e238ed645892fbca0111445e8f6592ab425c5caaff6a049da28bbb2078f615f73695cb80002a31377db8af4c72f34058d2e85e611be92be73a399d46361ddc2e7dc3dfc76545da40860bfe5784096831c4d16844192b951b08536954d8db07e747dac6488184a57bcfa5b4b4681d0d01eff0412903c85418cb6632fb382d035f62160843aa8cf7a0fa3db77af46f14ef1fe624ec48d038bbd8355716b0c9656f465ab3c9a7d4dd97cfb244d29d5563ad43d08820550efdc0cc6f168ed5dd2719ffd8cc777f40a48bfc5224147efd1fe07b61a2c227279fb8a0e0f07c6a82063d7a0ed8e4a41525b228ff464bec19724d16ad79283fa2277e3bcd69a42c60777816cd35e567b08dd614f0cbebd639483d7339a4adfa205de8598f54245e27689c0c990dcd68ce6dadef52bd99bc3de4f3c65952110fbc01252c13bd247aa1a6beceab0585bc8009993ce0921e1752365e7dbfcdf6568f4da949415cc70da6eccef4a525065934c9da57c62961ab509d4a01caaed75b120717630328c07b708b42e137e82e9d2589066809f0090e3e8afc770d5dd8dc8f2e038927863af6bbe1d2cadcd01317b306f13d8d681846a139feb566567433fb44181b7fcabcb994cdb6934511b3e359898bd06725af25d877f7391fd0906934d15b33fc6390b50877e1dfcf95e71aa09a636cd1237b0d6acf3cf77e7b75d6c49f291d9b8a1ec2ff0b38226870e25fd4cc8af6c3dbf5c53dc3e253adf948095e0b3b64bc628e491ffda2fe4ac80fe1ade53fc624ff584068e4e7ac694be6a7761f58e4736c1415c1abac2b543efa906be07504d38b2b7635ac41236fdac1a5276ef7f399c730468a414a77873be2b527c59ff7a661e08cf8f58fd5b0924849440c148641bb3ed14a6991037813fc93e83506b5e6a12605cf8e37e3606610af321205e561050925fd70525db0531eb02f6e9ba66c6402f3c30cdab803225f1d2f0bb8fef6ff5b297e5e97a693ac83b7f37102ecb3853762e00ed9fa2aaae3024ba2915df1cd6e6cd942cd038ccaae5827ad520898d6084cd6a5c5164101bb41651a1f7c04be16aafa4091860278fa92fc24d8eade9fa1addfe5c817f19b1b77358fa0d7c89369186942eafe2f83a650dd552cb5c27b8037f55b504dc8be630bdbbe646a00cb6c740ee976315a7ab915df53c3d45bcd112e8a4f518fe52f8a74fad27fb8a45df0b78afd86fdfe19a73cf7a82255d94be3ee1f4363791cbff64aee31c1dbbb4c49e5623a6671400cd54ddfff00c270d479f8ba5bb335346763d8a4b1d4efbad23383af460014d29115d4b80d1a89261fb2f1965a4d6f2f8aa0f4609f2e8e175bd549c31f0a1bceca982366baea572922b814a11cdb3ac10065183c6688086aee25dcb3b75b99d4ea731a4abbbca8c2981de3fccde5276d60e942f4fb15b0ad4d71912201767d6cb9039bd3a3f734a8cc9167157271d9b1570ea8d6f4fe07597b23e30cfd79959053ef41108149db6ca5cbc81bb945c86f5652eb2e993b24436183fb26ac5b6f7f7d1d23836a2a598a0e880ddaf3da80b8936adce0e9785c4a33da3fea4dc3a28ae79083defa38c012450325083725d4c2bfff2d086719443c900f195238a4f2a136eec9c480e6fb486a9d4b3bf3a387330660acf4826e58f18534aa7847f0ba654245c731ac5946e1a80f4f8b983ffb119b9f1ebe81a769ef12db084d2ad4d03dfe99881c7f5ec130ca91132aeb039378f6f0978a67595e1672277593e9c465acea25977f8a697be0724d63d2dc4d23cf2867032e27af3ecb841dc69088c520df1c8ba58229b5aa6f35fcd2adf0f4767ec536457dfd222b1699c27e67f148f2c6883a788c9fc3714f852fbd238b1fa1b07c2b64b555f17ef3886a017e850686e89fbc5e12b149686460ba7339293080ed461e4d21edae25be1c5bc5bc840eeb4f3ed6d3145e08202e91fd50de7e5ce7486ed8ae223426fc6549b5cfe5cdc0cca3a0b9349fd88b50a4242ca74d30cfac4f284445f90a200a84ca57852920f2aa18f1127786330e11302dbf7c9696d43418a471a0de00a4b930a62bfdede4ba0cb134e68d15829c9cf0dbc1b75f01c396b5863ccdfa2636733f3108ac1305b45e1275cba4c53e4990a767571a6836197d25f525eb207ff36f318c7aca597baf0e4edc26ec1041308848ccafb45ca7ebfba0e4da8ad4e1040f601d4247fe1ffbe1cda0a7ceabd058cfa8ae3171bf4b1335b609d62ba89dfc4b7a8f0f2035560f42d07e2651693216200fb126ab962cca164880d023d0e7cf159f8407308c4fc5dc80d50369d72308c562a984f11d9200516581b7feee03400d7482ad7df32991177ac192d516e544acc14dec36267ff35f1cedaaabf335af71740643f1b6f83a298b43c0a32cb27ee868bf3ec824d82669597bd3171e7b8a729dfc2a608e199cec0a66fb35e371820f58c66e0dc6e1c4d247b5a7b970f1255349bcc0595f03b030ce570259ce64834b56b293fc38de861790e8ade489df97b51b1de52db912977215634f66dc3f04845535fdea27247008bc25fdfab3f2d6e5dcfb5cc30030668044f9414c020c4bd9eea2166feb6dc9199f86c876602ea5f12252d5ddce61181e19f67a03d5abae014319311733637cfccdb1e8d0fcbedc2e58b5f72133098acba1fba54a9106939fb5430f2075b3ac8f9e7072705b399fad6d0613ff678e7ca87419cd8f5ee0383d57f17494f710a423a4653fd3b72265c691e4ab767368f7b7b42d05b030f1143db99e08d8fad45d006b1eb222fdd585b63ff9f9f0c16cb716cff9f6b5580435a1488024eefe7604ea9a1cdbb94eb2e8472bffcc47c8929287d6ab2125798b3f1d3f095bfb5bb854ab10b06e8a41611efc8e75ea07b2a151685a788f7d45baff4651ec4ef44107c122c19d07ef6e20cfc3837768f2fafe02b47f09a5fc1ba65284147f1292029c159a96c5749f4c209897552c191f4f129c4451bec81068786bb1c93b821f4abac76570372b70104d47d5f89d64f98fca5af177b5f0202519e322db9fd6158cf95de44c7be900f11e215006aa6f55feee337bb8b55e1821afbd3797782438a69259f70f6e4524530ebc1477ec6bbbbc3790bd54ddc6ab624077db237d062fc4eebacf62d61b63dd1f193f59f4ce2adcee4af8656bf9b82548f6ba8ceb3d8fdd581119f50b379c9181b6ba2472ac027b575aa3c798f91206c8a44b5c6356241a82dc3a35e59843635ed58b17808d88e7b242281bfa395a7c5b4cbdcbf9be1a71eecd5c780586a342ab128e2d735b8bd4d4e62613cda5b600655a41fd53f5d66c2c5c3ce9a7198d9bf5020deb53943bf882407b520860fb42dd3e01149ac745660224e76a6d4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
  </entry>
  <entry>
    <title>编译学习-虚拟机部分--20230518</title>
    <url>/2023/05/18/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E5%88%86-20230518/</url>
    <content><![CDATA[<h1 id="编译学习虚拟机部分"><a href="#编译学习虚拟机部分" class="headerlink" title="编译学习虚拟机部分"></a>编译学习虚拟机部分</h1><span id="more"></span>

<h3 id="1、支撑知识"><a href="#1、支撑知识" class="headerlink" title="1、支撑知识"></a>1、支撑知识</h3><h4 id="关于电脑内存"><a href="#关于电脑内存" class="headerlink" title="关于电脑内存"></a>关于电脑内存</h4><p>电脑中的内存是虚拟地址映射到实际的内存上，而非真是有这么多。</p>
<h4 id="关于本次使用的内存段"><a href="#关于本次使用的内存段" class="headerlink" title="关于本次使用的内存段"></a>关于本次使用的内存段</h4><p>简单来讲，进程的内存会被分为以下几个段</p>
<blockquote>
<p>1.代码段（text），用于存放指令代码，位于较低地址。（可能是指令需要改动不多甚至不需要改动，放在一些低地址区域，该区域可能是只读的）</p>
<p>2.数据段（data），用于存放<strong>已经初始化的数据</strong>，例如<code>int i = 10</code>就是已经初始化的数据，需要存储到改位置。</p>
<p>3.未初始化数据段（bss），顾名思义，就是存放<strong>未初始化的数据</strong>的地方，例如<code>int i[1000]</code>就是属于只声明而未初始化的数据，存放在该段。</p>
<p>4.堆（heap），用于为程序动态分配内存。</p>
<p>5.栈（stack）用于处理函数调用的相关数据，例如调用帧或者函数的局部变量。</p>
</blockquote>
<p>在第一点中提到在代码段在内存中位于低地址区域，那么如下图所示：</p>
<p><code>图一</code></p>
<p><img src="/2023/05/18/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E5%88%86-20230518/%E5%9C%B0%E5%9D%80%E5%88%86%E5%B8%83.jpg" alt="各部分地址分布"></p>
<p>个人理解：在计算机内存中，低地址是不允许写入的，其中存放的数据都是一些系统级的或者是常量，例如数字（0-9），字符（a-zA-Z,.&#x2F;等），当程序需要时，就只能读取而不能写入。</p>
<p>而在高地址字段，例如堆栈，可以实现内存的动态分配和数据的调用和修改，即可读可写，提高了与用户的交互性。</p>
<p>为简单起见，本次只关心 <strong>①代码段 ②数据段 ③栈</strong></p>
<h4 id="③寄存器"><a href="#③寄存器" class="headerlink" title="③寄存器"></a>③寄存器</h4><p>寄存器用于存放计算机的运行状态，真实计算机中有许多寄存器，本次只用4种。</p>
<blockquote>
<p>1.<code>PC（Program Counter）程序计数器</code> 存放内存地址，该地址中放着<strong>下一条</strong>要执行的计算机指令</p>
<p>2.<code>SP（Stack Pointer）指针寄存器</code> 永远指向当前栈的栈顶。因为栈顶是由高地址扩张到低地址（可以参考图一，栈底在最顶端）所以当有数据入栈时，SP的地址值减小；当出栈时SP的地址值增大</p>
<p>3.<code>BP（Base Pointer）基址指针</code> 也是用于指向栈的某些位置（不想确定的位置，也并不是不能指向栈顶）</p>
<p>4.<code>AX（Accumulator Register）通用寄存器</code> 从英文上看出是累加寄存器，在虚拟机中，用于存放一条指令执行后的计算结果。</p>
<p><strong>PS：前三个都是存放地址的，定义是要指针定义，而AX是存放结果的，不用定义成指针。在实际计算机中，PC的初始值应该指向main函数的地址，但是现在 还没到这一步，先不指定。</strong></p>
</blockquote>
<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可不可以用unsigned int？？？</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><h4 id="类型问题"><a href="#类型问题" class="headerlink" title="类型问题"></a>类型问题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LC)   &#123;ax = *(<span class="type">char</span> *)ax;&#125;      <span class="comment">// load character to ax, address in ax</span></span><br></pre></td></tr></table></figure>

<p>if中的操作是将ax中的值作为地址，并且按照char类型解析该地址指向的内容，然后将解析完后的char重新赋值给ax，应该会导致类型冲突的呀。</p>
<blockquote>
<p><strong>解答</strong>：在计算机内存中，不论是<code>int</code>还是<code>char</code>还是各种指针类型，其实都是一个数，而<code>int</code>，<code>char</code>或者是<code>int*</code>，<code>char*</code>是决定程序在解析这个数的时候的方式（往后读多少个内存单元，按照什么类型解析）。</p>
<p>改代码中，如果ax不是很大的数（8位以内），可以正常运行，再大就会出现转换错误的情况。</p>
</blockquote>
<h4 id="sp-sp-pc"><a href="#sp-sp-pc" class="headerlink" title="sp = sp - *pc++"></a><code>sp = sp - *pc++</code></h4><p>将栈顶指针sp 减去下一个指令需要使用的空间大小，pc++是指下一个指令的地址，解引用后就是指下一个指令，同时是一个int值，为什么指的是下一个指令所需要的空间大小？</p>
<blockquote>
<p><strong>解答</strong>：在函数调用时，一个函数需要多大的空间运行，一般都会在函数内部用一个小空间存储这个内容。</p>
<p>这里将这个内容取出来减去，就是回收之前为子函数开辟出来的子函数提前告知的需要的空间。</p>
</blockquote>
<h3 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h3><h4 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h4><p><code>int * </code>和<code>char *</code>本质上都是指针，而指针都是一个数字，而计算机内指针都是用数字表示的，为什么不统一用int或者是unsigned int，而是要分int char和其它？</p>
<p>因为<code>int * </code>和<code>char *</code>指向的数字表示不同的数据类型，而且还是做指针运算时的重要依据，比如在int类型中，指针运算++是向后移动4个字节（大多数机器是这样的），而char类型在做指针运算时，往往只向后移动1个字节，计算机做出这样的依据就是所使用的指针类型。</p>
<p>其次，在计算机编译阶段，这两种类型对应存储的数据需要不同，计算机在编译时会检查<code>int * </code>和<code>char *</code>所指向的数据是否正确，若不正确则报错，避免潜在的错误。</p>
<p>GPT这样说：</p>
<blockquote>
<p>int *和char *在本质上的区别是指针所指向内存单元中存储的数据类型不同。</p>
<p>int * 是一个指向整型变量的指针，它所指向的内存单元中存储的是一个整型数值，占用 4 字节（在大部分机器上）。而 char * 则是一个指向字符型变量的指针，它所指向的内存单元中存储的是一个字节大小的 ASCII 码或者 Unicode 码。</p>
<p>在计算机编译时，int <em>和char * 在指针操作上会有所不同。在执行指针运算时，指针所指向的内存单元地址将根据数据类型的不同而发生改变。例如，对于一个 int</em> 指针变量 p，执行 p++ 操作时，p 的值将增加 4，因为一个 int 变量占用 4 个字节。而对于一个 char* 指针变量 q，执行 q++ 操作时，q 的值只会增加 1，因为一个 char 变量只占用一个字节。</p>
<p>此外，在编译器生成目标代码时，对于 int * 和 char * 所指向的内存单元，编译器在生成代码时还会进行类型检查。这是为了确保程序不会访问不正确的内存地址，避免潜在的错误。例如，在使用 int * 指针时，我们只能访问整型变量的内存地址，不能访问 char 或其他类型变量的内存地址。</p>
</blockquote>
<h4 id="关于栈顶"><a href="#关于栈顶" class="headerlink" title="关于栈顶"></a>关于栈顶</h4><p><code>SP指针寄存器</code> 永远指向当前栈的栈顶  此处的栈顶是最顶端的元素，而非最顶端元素的上面一个。</p>
<h4 id="一些骚操作"><a href="#一些骚操作" class="headerlink" title="一些骚操作"></a>一些骚操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SC)   &#123;ax = *(<span class="type">char</span> *)*sp++ = ax;&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的运算顺序是：</p>
<p>①sp++申请新空间</p>
<p>②*解引用</p>
<p>③将ax的值存进去</p>
<p>④char * 强转</p>
<p>⑤*解引用</p>
<p>⑥将值再赋给ax（如果ax中的数字小的话，其实没变）</p>
<h4 id="pc-1和-int-pc"><a href="#pc-1和-int-pc" class="headerlink" title="pc+1和(int *)*pc"></a><code>pc+1</code>和<code>(int *)*pc</code></h4><p><code>pc = pc+1</code>是指顺序执行下一行代码（从上帝视角来看）</p>
<p><code>pc = (int *) *pc</code>是指跳转到下一个语句块</p>
<p>从JMP指令的实现是<code>pc = (int *) *pc</code>就能看出，如果if后面是0，那么则回执行<code>pc = (int *) *pc</code>，实质上是进行了一次JMP。</p>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译学习资源</title>
    <url>/2023/05/09/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="编译学习"><a href="#编译学习" class="headerlink" title="编译学习"></a>编译学习</h1><span id="more"></span>

<h4 id="两本书"><a href="#两本书" class="headerlink" title="两本书"></a>两本书</h4><p>《深入理解计算机系统》（第三版）可以看。中英文都有电子书，看着玩。</p>
<p><a href="https://www.aliyundrive.com/s/bKVNaXMakYF">英文《深入理解计算机系统》</a></p>
<p><a href="https://www.aliyundrive.com/s/vDQCkVCdThz">中文《深入理解计算机系统》</a></p>
<p>《编译原理》（第二版），其实也就是龙书，偏原理，老师推荐我先写起来，自己写着玩玩。</p>
<p><a href="https://pan.baidu.com/s/1_xTFRTalGZc_XiGfW7ND2A?pwd=zhao">《编译原理》（第二版）</a></p>
<h4 id="三个网站"><a href="#三个网站" class="headerlink" title="三个网站"></a>三个网站</h4><p>①<a href="https://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器</a></p>
<p>②<a href="https://space.bilibili.com/296494084/channel/collectiondetail?sid=571708">编译器B站视频</a></p>
<p>③<a href="https://github.com/rui314/chibicc/commits/main?before=90d1f7f199cc55b13c7fdb5839d1409806633fdb+315&branch=main&qualified_name=refs/heads/main">Commits · rui314&#x2F;chibicc (github.com)</a></p>
<p>慢慢看吧，之后有新的资源会加进来的！</p>
<p>收藏夹吃灰系列</p>
<p>END</p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译设计</title>
    <url>/2023/05/12/%E7%BC%96%E8%AF%91%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="着手设计"><a href="#着手设计" class="headerlink" title="着手设计"></a>着手设计</h1><span id="more"></span>

<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>学习<strong>手把手教你构建C语言编译器–设计</strong>部分</p>
<p><a href="https://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）- 设计 </a></p>
<p>试写了文章中的代码，虽然成功了，但是有点问题。</p>
<h4 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h4><p>编写一个编译器一般为<strong>①词法分析器；②语法分析器；③目标代码生成</strong>。以下为手写这些构成部分。</p>
<p>一个编译器的框架首先是有</p>
<blockquote>
<p>编译器包含四个函数：</p>
<p>1、next()函数，用于读取下一个标记，会自动忽略掉空格；	&#x2F;&#x2F;读程序</p>
<p>2、program()函数，语法分析的入口，分析整个程序。本部分不写；	&#x2F;&#x2F;做语法分析</p>
<p>3、expression(level)函数，用于解析一个表达式。本部分不写；	&#x2F;&#x2F;做语义分析</p>
<p>4、eval()函数，虚拟机接口，可以解释目标代码。</p>
</blockquote>
<h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><p>以下是代码块，和教程上的代码一模一样，，，，，</p>
<p><code>code01</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">char</span> *src, *old_src;</span><br><span class="line"><span class="type">int</span> poolsize;</span><br><span class="line"><span class="type">int</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取src中下一个字符的ASCII码值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式分析pewpwd</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expression</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件，直到token小于0（因为token是ASCII，所以没有小于0 的情况，等于0就是结束符）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    next(); <span class="comment">// get next token</span></span><br><span class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;token is: %c\n&quot;</span>, token);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机接口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eval</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">// do nothing yet</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    poolsize = <span class="number">256</span> * <span class="number">1024</span>; <span class="comment">// arbitrary size</span></span><br><span class="line">    line = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(*argv, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;could not open(%s)\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(src = old_src = <span class="built_in">malloc</span>(poolsize)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;could not malloc(%d) for source area\n&quot;</span>, poolsize);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the source file</span></span><br><span class="line">    <span class="keyword">if</span> ((i = read(fd, src, poolsize - <span class="number">1</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read() returned %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src[i] = <span class="number">0</span>; <span class="comment">// add EOF character</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h4><p>①第三行 include 的 memory.h 好像没用到（可能之后会用到吧）</p>
<p>②第52行，open函数中的参数，第一个参数是取用户输入的第一个参数，但是第二个参数不理解。</p>
<p>翻看了函数原型，代码如下：</p>
<p><code>code02</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__fortify_function <span class="type">int</span></span><br><span class="line"><span class="title function_">open</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__path, <span class="type">int</span> __oflag, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__va_arg_pack_len () &gt; <span class="number">1</span>)</span><br><span class="line">    __open_too_many_args ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p (__oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__OPEN_NEEDS_MODE (__oflag) &amp;&amp; __va_arg_pack_len () &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  __open_missing_mode ();</span><br><span class="line">	  <span class="keyword">return</span> __open_2 (__path, __oflag);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">return</span> __open_alias (__path, __oflag, __va_arg_pack ());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__va_arg_pack_len () &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> __open_2 (__path, __oflag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __open_alias (__path, __oflag, __va_arg_pack ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是int类型没错，但是具体含义不知道。</p>
<p>上网查后，解释是，第二个参数代表对该文件的操作权限，例如：只读，只写，读写。但是很神奇，这些权限的表示方法如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">flags 参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O_RDONLY</td>
<td align="center">只读模式</td>
</tr>
<tr>
<td align="center">O_WRONLY</td>
<td align="center">只写模式</td>
</tr>
<tr>
<td align="center">O_RDWR</td>
<td align="center">可读可写</td>
</tr>
<tr>
<td align="center">O_APPEND</td>
<td align="center">表示追加，如果原来文件里面有内容，则这次写入会写在文件的最末尾</td>
</tr>
<tr>
<td align="center">O_CREAT</td>
<td align="center">表示如果指定文件不存在，则创建这个文件</td>
</tr>
<tr>
<td align="center">O_EXCL</td>
<td align="center">表示如果要创建的文件已存在，则出错，同时返回 -1，并且修改 errno 的值</td>
</tr>
<tr>
<td align="center">O_TRUNC</td>
<td align="center">表示截断，如果文件存在，并且以只写、读写方式打开，则将其长度截断为0</td>
</tr>
</tbody></table>
</blockquote>
<p>如表所示，并没有数字，不理解。。。。。。</p>
<blockquote>
<p><strong>解答</strong>：这些flags参数是在一个枚举类型中的常量，如下代码所示：</p>
<p><code>code03</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    O_RDONLY,   <span class="comment">// 只读打开</span></span><br><span class="line">    O_WRONLY,   <span class="comment">// 只写打开</span></span><br><span class="line">    O_RDWR,     <span class="comment">// 读写打开</span></span><br><span class="line">    O_APPEND,   <span class="comment">// 追加方式打开</span></span><br><span class="line">    O_CREAT,    <span class="comment">// 若文件不存在，则创建该文件</span></span><br><span class="line">    O_EXCL,     <span class="comment">// 与O_CREAT一同使用，如果文件已经存在则出错</span></span><br><span class="line">    O_TRUNC,    <span class="comment">// 截断文件长度为0</span></span><br><span class="line">    O_NOCTTY,   <span class="comment">// 不要把设备用作控制终端</span></span><br><span class="line">    O_NONBLOCK, <span class="comment">// 非阻塞模式</span></span><br><span class="line">    O_SYNC      <span class="comment">// 同步方式打开</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码就是一个枚举类型（包括之后的指令集也是枚举类型），从第一个到最后一个按照自然数（0或许不是自然数？）顺序排列，比如<code>O_RDONLY</code>就是<code>0</code>，以此类推。。。</p>
</blockquote>
<p>③当我运行这个文件时，即执行下列命令</p>
<p><code>code04</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$$ gcc 01.c -o 01</span><br><span class="line">$$$ ./01 01.c</span><br></pre></td></tr></table></figure>

<p>逐个字符读取只读到了第11行的&#x2F;&#x2F;和其后的一个空格，程序就中止了，不知道为什么。。。。。。</p>
<p>开始觉得是因为后面是中文字符，于是在“读取”前面随便加了几个字母，发现读取成功，但是<strong>将后面的所有中文语句换成英文之后又行不通了</strong></p>
<p>又试了一下，一读到注释就不行了。</p>
<blockquote>
<p><strong>解答</strong>：其实就是字符问题，因为在<code>next</code>函数中，读的是字符的ASCII码值，而中文字符在ASCII中是没有位置的，因此读不下去了，所以文件中避免出现中文。</p>
<p>其原理是，读取函数根据数据类型（其实所有的都是这样的）决定本次读取往后读多少个字节单位，而char只有一个字节，但是中文字符占两个或者三个字节（根据编码不同而相异），因此不能继续读下去</p>
<p>如果将第28行中的<code>token &gt; 0</code>改成<code>token != EOF</code>就可以成功读完文件，但是对应的中文都是乱码，而且由于前面中文出现了“断章取义”的现象，后面的英文大概率也是乱的。</p>
<p>还有一个方法就是用wchar类型，也就是将第7行的<code>src</code>和<code>old_src</code>定义为<code>wchar*</code>类型，这样就可以正常读中文了。</p>
</blockquote>
<h4 id="5、TIPS"><a href="#5、TIPS" class="headerlink" title="5、TIPS"></a>5、TIPS</h4><p>①先看第64行，src里面是读取的文件内容，和第69行联系起来看，第69行在 i 的位置加了个0，即为封口。于是 i 的值就有点耐人寻味了。</p>
<blockquote>
<p>read 函数 返回值有三种情况。</p>
<p>1、读取出错，返回-1，即有如果 i 小于 0 ，那么直接print错误</p>
<p>2、读取时，未达到第三个参数设置的大小就读完了。这是最正常的情况。此时返回的 i 就是大于0且小于第三参数。且为已经读到的字节数。（个人理解为就是EOF的下标，后面才可以在 i 处封口）</p>
<p>3、读取时，文件大小超过第三参数大小，即没读完就读不下了，这时返回的仍然是已经读取到的字节数，但是比较特殊，其值等于第三参数。</p>
</blockquote>
<p>除了读取错误返回-1，其余两种情况都进行了封口操作，即便有一种情况是强制封口。</p>
<p>②从51行开始，到55行，其实做了两件事：第一、open文件；第二、判断错误，如果文件描述符fd小于0，那么打开文件错误。</p>
<blockquote>
<p>文件描述符返回值：成功则返回0，失败返回-1</p>
</blockquote>
<p>同理，先两个if代码块也是如此，先进行相关操作，再判断操作是否错误</p>
<p>任何错误都将直接返回-1</p>
<p>③next() 函数中 token 读取的其实是ASCII码值，并且通过地址将值带出。</p>
<p>④第46、47行，有个argc- -和argv++</p>
<blockquote>
<p>argc- - 意思是将参数减少。通过查资料可以知道，main函数自带的两个参数其实是本程序的输入参数个数（argc）和输入的参数构成的数组（argv）。值得注意的是，这两个参数都包含他们自己。所以argc初始值就是2，agrv[0]初始值是2，argv[1]初始值是argv（即首地址）</p>
</blockquote>
<p>运行时要解析命令，先把第一个用户输入参数去掉，argc- -，因为第一个往往是调用编译程序的参数，当调用到正确文件时，就不需要第一个参数了。</p>
<p>argv++是地址++，就是跳转到下一个命令参数，然后给程序读取，执行相应操作。</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
</search>
