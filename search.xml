<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>chatgpt镜像</title>
    <url>/2023/05/06/chatgpt%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7beb9758fd6664143f3df7975372238161c601144ded625797ba1b969527a7ba">4630436162ade97ba2718b7d0c4b3b63492810e13ad85be96e947ea4cb65291430a49bb22ad32d84514670596647149d7c92fe70cc097ce99432d6eddecce600fad1be98eebf5ebc7267d7570a201229361d4601678f68284fac1faa62f257283de9c1d84d76d52a5d274a0ee68cafbfb91d67d40a478ff73a1ad594d725f4da9498f1f68e505b55bf44b90b8ef5feae4de5a06f4d567e6c2d194242617d2bed2a2b0d60b841753c3e1dcc3f00300b27691e5ffc477dfa6bcd8f8cc6bce4d54cae1b1ca80b7220554bf03c25e69fb7a5073c4ba05eb2bd3c9e0f8eec510d1acecd510767dc145016e3a07d486ab66fb5493658d1c5ffc1b1fbbf8ce6c9ffb8a5e3e4d0e42004203d5db442eb2f7206fa4a31054912f2428aba3c5b62bbdf601b83c3e3434d481590219e979cfc12f1c02756d30174bccf981abc1edf19f8725f0bb920ad5eaca2ad404607adde4dee9aebb3be366203a4393a2b324c439a6e57407dc13a9b1ae9c375123f1645ea6268a5215d0fcc6dfc46d951222ed405e44e49e78104be5dd5674ca8def738053863480150529d69b87a45a8788ba517ecfd1ab5ac8e38e2741ac0f8c4383df5930be5bb8bcc284aa9aac5e434770a032dee240dc6549e8e800afd9954fd51663dcd15b735954903f2036daf0e434049f27dba3f3d143b614545f26acf5d161b6ccc96d5f471bda843facdf9ba37f0a02fde454aa6af0c81eec42693e0feae575e381303f41e1ed50dbc4fad93738baab316c2ada34affbfc44f9265fe4e0a85cf35b543bce952ed93f1d87af67d6b3617008373a081675e1c3d05747eff2051b5cb316c740d36132a263b302ce245f0079f2a23384a442ec7a4746039bea493700ae105d1b9f286e7ed9a8c670c9b377487e9193531853be2eb3499f7e64f5f415506ab41cea87d217068baf64dfd137e738c94050e3c44a040dc385eca0d360c3c88cb447d783ccbe0b46866f318d459677869888c33e16105042f9892b3897d8c16b92585978201d35cce7740821d2b915aa94d49735f7be058242dad461b4892442830e6344be389c0d965690e9a2d30f6b1c07db59756f3210947333da4e4bbf96cf05c3f7d41f0be38ba0dac374c4357393fa84b8a3da4acae8b698c67dedc8bba49db46fdcf0fda5203c83c0c6591f48790a4bd4c75168b0dea6117b176f83a9f0b59e68e3fec8f06c4ffa262028c1efcbacad7d0262b3151a45326fcb28b4b804c69333257e7aef59ee7fd732ca3cbf92e36cef2ed8624318fea85f562cf243988c9b90d5a503f004a8a8e88a96699285f7a54509ac44f289acf346a35b95444bb2621e0eff711f716d16618a370f295378f33307f77dc891a67db10c20d4debae8a802dfaf520412b0828d0aa017fde902b4d2851b83d35d9579d2b99a8d1caf2b6fd9544ff7f6c66af89e2e8972fe00693b388a24173bf42d2838f726bb97bec2a11e25ff8b3fd3668911c3c72c8db6030a98b67a313dc19ba6fed53f890a8c57617b7f07373b746a0bdd0e37fa0f7bcccaa93d601aa11d11cf4377628e19a975e2f40e0129629e90c737cf1d888677884a00a3ce04029b107a5dbf3ee711ff17ed73330d8f0e4d172ae40d6a5c4de55c8ede96ca5cf5eee9074c0594608bc128e59707ed59d3271bd2c9a0ba8b9a18082ffebe4c148bf1689c0a8e228e4d9d39a6e9c2b9fac311018a86da11b61c22c61a00100c5241ca8a5b2574382cea775aa17052d35ec6fe37d2389ce094a2da54a03c96112553f7c26d380d7f52f418f02298da6dfe829defd46dc1a0c5d31cbf8c28857fab294bcb458464e0586c26126cd61b98cf789848fe2783c811138feaffee580d032ce932cf7931540e20199ecfcd59b186fa1759ecd082ddb353226c2cea2404c467bd3ce30c8eeed473928ff4f27acbedfe26ce3ed4ecd4dc87f2d296602775c6733d7dd14ca6ae213845ffecd87c1bf45a0bb5263dbd20e8cd061a96f05aba4e770f963966d5aebc1ad14129f329d75cf262a71f100473e1b6ec3af60b283c033c5956dc965bbb9b90a076efb439eb604fe93579678595600dde7ac0d76551b4788633a841a6c3a230141187e6794460107230a69e017b0d35617a68002a3ccb06e183fb33a0b21e8e5783ddbed84e32b7f6c5883a98222583c24d03ceddec98873eada1fd0b61cd3f10f2c818ad40d9622f37c653facfff2824f2fca83d0c6ca07876339ed128c94faf29242101a79193c32304ebcaa1e3c5d865341ca8bbc0dab90f5f459c0bf0b0c50d5c0e2edbd79b0fe25e36c155cf2ff6f91814270f2e4d54950f7a249a919fd4cdea45b653e53676f6ac402e0c794b411023ae460a41edcfd24698ffcbf92e5c30cc5c6cdbf211fb64e74636d6de56bbdee88920fe87dfb59f534ddd98c5aac8aba9fb1243e1d0ff47a7fd4172cf1b0a9efd8f3af94354fa58da2deef458ba4ce6ad1778a93b8d7718f779ac3189c6be49e0edc2538082837f1f090beda0b0b3362943213f5c1aa9f6bbe28914b086988503ce1603c3627260c10f575a3481b31c630a94499da2c8f536aca35845bd4e50c9adfd6d32019502dd15d8e02ea83a8bb584e110a2d1a9a9fd3bac98b9f8333e33b6cac78b4264cad76c9a9265f93571bb42fc594cc94506126e01ee71dd9f0da3930edce74b03e24749e105572403b482721da43008cb09b3fa9c418ce39d1475353a7bfc29be01e482107b2cdbf366ecda0af9ccc5dc678cbb9055d99a7e15ff8196740e414018fa65b12c603f3e1de5fb5a9d9a55bbccb803b400db1746862dcfd64646de25aec7696850f8627f55d486528ad18257640aed82bf2e91c0b1d11845dc6457ef55eda666f96729d74dac58c67b8af13b6e27c22854d6301d0f296ebd5e079d50505590e22847bb99d4c69b6bfc2e582e9fd825c8f66defe5ecd93486e93f67a4eb280a49e0b251668a23e16fd1bf0f64d8bc5557d9a745655c51081abf7dba39a5448db984fbb26c36f2f9162145ca0a9d1dc44e5e4a4f5826947875bf8dd40f47691cf550da82c811c859036e245c116b51382286fa3dd5b4ab29f00dfbb9fe5d9abae90c835d96d4239c44fe6a318e56c817008f618e2a23e7c59e76a13b034aa185fd9aec91389dc3dbd80c0c705edf933cecc531363a3a206a1b9c67a1399269a699e8a2d6c015f58d0d84b63f9f93b25dcd443720190486a693cec2cc14dcdb0e1705f9cc8f01814f89a97088eecbe4b21b26259562a47f573d3780fa8db20f3b08c782870f4fbe8622f6819f88d5623eaea9aca12c45a22210857e8238d1d7610b8305a65c6ef9b57ed07443e86ded6cb819ea817de5dcf152ba65b4c449100220ae43259222fa5d22b04043c0ac364965c571dc0b320d7630d1cba4e469b3c857e9775b9601a2d7a44a3900c5148351def220634895dfaeb573654263d0df7fc31bbbbe46efe2e498e191467dcf9d2cef8d51bf0de3bb54c0a8a60708d9480a937fddf3f28a49411bc18c40338348e2be8349fd8d98672570452f331f73d737ea29bbabed733867e82b46454852beb1df7acee1b926de84ba17fc77d2f93bb122869d4b7edfe211cdd4b120ad1e59beee902f16bb34e884b97c6351b6c19d7fd2eaf198a565a96b1525c9c6ee3fb3ca252dc8a9598a5ec682f8518a7b6fcaa9f5b628fa8d1e99857b100b068908721df1363f44179b22831116cbe20d40f68df7e10a210aba69864e75ba14540751afb65c99f0c32164b2abeac25c17e95f41c15f49dfca5699f751b1da68e8f3ddd1311306688320c6fbd7ba958a24a38b5a903d5f8e79bc8088a421ac9756d4d87ea4e83b48edef9b6275f62a68908f892e6ff33f0c6c7074ce833376ed8baeb0692e93698ee0471667b72ef0df5f48432d12f454ba02a810d4c942d1061036129c1a104fd6c8a7671409a75e774e52ab08bfd2e6a6311cca7ad39d51c67aa5fe0484d05573c86b1264b4527b4fbc4712bce8bc7c45e598cbb117cc53ce270a1524a28b379c3a0b12667fd2d61ad016dd59839dc8426a11cf1da9231ff701b080e87b5f9184471f76529c6d5238952f2321302d0a202ab1f72b8ee83cc58b3fabdf13c1b660c23b327109eeb99b4bc4e89dd0545</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>chatgpt</category>
      </categories>
      <tags>
        <tag>chatgpt镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>编译学习资源</title>
    <url>/2023/05/09/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="编译学习"><a href="#编译学习" class="headerlink" title="编译学习"></a>编译学习</h1><span id="more"></span>

<h4 id="两本书"><a href="#两本书" class="headerlink" title="两本书"></a>两本书</h4><p>《深入理解计算机系统》（第三版）可以看。中英文都有电子书，看着玩。</p>
<p><a href="https://www.aliyundrive.com/s/bKVNaXMakYF">英文《深入理解计算机系统》</a></p>
<p><a href="https://www.aliyundrive.com/s/vDQCkVCdThz">中文《深入理解计算机系统》</a></p>
<p>《编译原理》（第二版），其实也就是龙书，偏原理，老师推荐我先写起来，自己写着玩玩。</p>
<p><a href="https://pan.baidu.com/s/1_xTFRTalGZc_XiGfW7ND2A?pwd=zhao">《编译原理》（第二版）</a></p>
<h4 id="三个网站"><a href="#三个网站" class="headerlink" title="三个网站"></a>三个网站</h4><p>①<a href="https://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器</a></p>
<p>②<a href="https://space.bilibili.com/296494084/channel/collectiondetail?sid=571708">编译器B站视频</a></p>
<p>③<a href="https://github.com/rui314/chibicc/commits/main?before=90d1f7f199cc55b13c7fdb5839d1409806633fdb+315&branch=main&qualified_name=refs/heads/main">Commits · rui314&#x2F;chibicc (github.com)</a></p>
<p>慢慢看吧，之后有新的资源会加进来的！</p>
<p>收藏夹吃灰系列</p>
<p>END</p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理实验1</title>
    <url>/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<p>实验一：直方图均衡化、对数变换、幂次变换</p>
<span id="more"></span>

<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握基本图像增强算法的实现</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul>
<li>直方图均衡化图像增强</li>
<li>对数图像增强</li>
<li>幂次图像增强</li>
</ul>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="直方图均衡化图像增强"><a href="#直方图均衡化图像增强" class="headerlink" title="直方图均衡化图像增强"></a>直方图均衡化图像增强</h3><blockquote>
<p>①对图像遍历，统计出每个像素的出现次数（即频率），形成直方图</p>
<p>②对所有频率求和</p>
<p>③对直方图的每个频率除以所有频率的和，求出归一化到0-255的范围</p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/%E5%85%AC%E5%BC%8F1.jpg"></p>
</blockquote>
<h3 id="对数图像增强"><a href="#对数图像增强" class="headerlink" title="对数图像增强"></a>对数图像增强</h3><blockquote>
<p>s &#x3D; c * log(1+r)</p>
</blockquote>
<h3 id="幂次图像增强"><a href="#幂次图像增强" class="headerlink" title="幂次图像增强"></a>幂次图像增强</h3><blockquote>
<p>s &#x3D; c * pow(r,γ)</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 使用PIL库读取图像</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图像，L 代表灰度模式</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">histogram_equalization</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 获取图像的直方图</span></span><br><span class="line">    histogram = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">    width, height = image.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line">            histogram[pixel_value] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算累积分布函数 列表</span></span><br><span class="line">    cumulative_distribution = [<span class="built_in">sum</span>(histogram[:i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化到0-255的范围</span></span><br><span class="line">    normalized_cdf = [<span class="built_in">int</span>(cumulative_distribution[i]/cumulative_distribution[-<span class="number">1</span>] * <span class="number">255</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用均衡化</span></span><br><span class="line">    equalized_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line">            equalized_value = normalized_cdf[pixel_value]</span><br><span class="line">            equalized_image.putpixel((x, y), equalized_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> equalized_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    input_path = <span class="string">&quot;../clear.bmp&quot;</span></span><br><span class="line">    original_image = read_image(input_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行直方图均衡化</span></span><br><span class="line">    equalized_image = histogram_equalization(original_image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和均衡化后的图像</span></span><br><span class="line">    original_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    equalized_image.show(title=<span class="string">&quot;Equalized Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存均衡化后的图像</span></span><br><span class="line">    output_path = <span class="string">&quot;../historgram_result/clear_my.bmp&quot;</span></span><br><span class="line">    equalized_image.save(output_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对数强化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 使用PIL库读取图像</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图像，L 代表灰度模式</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_transform</span>(<span class="params">image, c, base</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line"></span><br><span class="line">    equalized_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对数变换t</span></span><br><span class="line">            log_transformed_value = c * math.log10(pixel_value + <span class="number">1</span>) / math.log10(base)</span><br><span class="line">            <span class="comment"># print(log_transformed_value)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将变换后的值限制在[0, 255]的范围内</span></span><br><span class="line">            log_transformed_value = (log_transformed_value/ math.log10(base))*<span class="number">255</span></span><br><span class="line"></span><br><span class="line">            equalized_image.putpixel((x, y), <span class="built_in">int</span>(log_transformed_value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> equalized_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    input_path = <span class="string">&quot;../lab1-7.tif&quot;</span></span><br><span class="line">    original_image = read_image(input_path)</span><br><span class="line"></span><br><span class="line">    base = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行直方图均衡化</span></span><br><span class="line">    equalized_image = log_transform(original_image,<span class="number">1</span>,base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和均衡化后的图像</span></span><br><span class="line">    original_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    equalized_image.show(title=<span class="string">&quot;Equalized Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存均衡化后的图像</span></span><br><span class="line">    output_path = <span class="string">&quot;../log_transform/lab1-7_my_&quot;</span>+<span class="built_in">str</span>(base)+<span class="string">&quot;_.tif&quot;</span></span><br><span class="line">    equalized_image.save(output_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 幂次强化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 使用PIL库读取图像</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图像，L 代表灰度模式</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_transform</span>(<span class="params">image, c, base</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line"></span><br><span class="line">    equalized_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 幂次变换</span></span><br><span class="line">            log_transformed_value = c * math.<span class="built_in">pow</span>(pixel_value,base)</span><br><span class="line">            <span class="comment"># print(log_transformed_value)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将变换后的值限制在[0, 255]的范围内</span></span><br><span class="line">            log_transformed_value = (log_transformed_value/ (math.<span class="built_in">pow</span>(<span class="number">255</span>,base)))*<span class="number">255</span></span><br><span class="line"></span><br><span class="line">            equalized_image.putpixel((x, y), <span class="built_in">int</span>(log_transformed_value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> equalized_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    input_path = <span class="string">&quot;../unclear.bmp&quot;</span></span><br><span class="line">    original_image = read_image(input_path)</span><br><span class="line"></span><br><span class="line">    base = <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行直方图均衡化</span></span><br><span class="line">    equalized_image = log_transform(original_image,<span class="number">1</span>,base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和均衡化后的图像</span></span><br><span class="line">    original_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    equalized_image.show(title=<span class="string">&quot;Equalized Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存均衡化后的图像</span></span><br><span class="line">    output_path = <span class="string">&quot;../power_transform/unclear_my_&quot;</span>+<span class="built_in">str</span>(base)+<span class="string">&quot;_.bmp&quot;</span></span><br><span class="line">    equalized_image.save(output_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>说明：第一行左边为原图，右边为直方图均衡化后的图；第二行左边为log变换后的图，右边为幂次变换后的图，参数会在对应位置说明</p>
<p>上传到网页，排版很可能出现问题，如果出问题，那么从上到下依次是 原图、直方图均衡化、log、幂次</p>
<p>下图log变换底数为300，幂次变换指数为5</p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/bright.bmp#pic_left" alt="bright" style="zoom: 50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/historgram_result/bright_my.bmp#pic_right" alt="bright_my" style="zoom: 50%;"></p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/log_transform/bright_my_300_.bmp#pic_left" alt="bright_my_30_" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/power_transform/bright_my_5_.bmp#pic_right" alt="bright_my_5_" style="zoom:50%;"></p>
<p>下图log变换底数为100，幂次变换指数为2</p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/clear.bmp#pic_left" alt="clear" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/historgram_result/clear_my.bmp#pic_right" alt="clear_my" style="zoom:50%;"></p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/log_transform/clear_my_100_.bmp#pic_left" alt="clear_my_100_" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/power_transform/clear_my_2_.bmp#pic_right" alt="clear_my_2_" style="zoom:50%;"></p>
<p>下图log变换底数为50，幂次变换指数为0.5</p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/dark.bmp#pic_left" alt="dark" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/historgram_result/dark_my.bmp#pic_right" alt="dark_my" style="zoom:50%;"></p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/log_transform/dark_my_50_.bmp#pic_left" alt="dark_my_50_" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/power_transform/dark_my_0.5_.bmp#pic_right" alt="dark_my_0.5_" style="zoom:50%;"></p>
<p>下图log变换底数为100，幂次变换指数为2</p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/unclear.bmp#pic_left" alt="unclear" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/historgram_result/unclear_my.bmp#pic_right" alt="unclear_my" style="zoom:50%;"></p>
<p><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/log_transform/unclear_my_100_.bmp#pic_left" alt="unclear_my_100_" style="zoom:50%;"><img src="/2023/11/17/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C1/power_transform/unclear_my_2_.bmp#pic_right" alt="unclear_my_2_" style="zoom:50%;"></p>
<p>下图log变换底数为100，幂次变换指数为2 （tif文件不能插入到markdown中，请看PDF文件）</p>
<p>PDF文件略有不同，影响不大</p>
<br>

]]></content>
      <categories>
        <category>数字图像处理实验</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>其它git使用方法</title>
    <url>/2023/10/22/%E5%85%B6%E5%AE%83git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一些其它git的使用方法"><a href="#一些其它git的使用方法" class="headerlink" title="一些其它git的使用方法"></a>一些其它git的使用方法</h1><span id="more"></span>

<p>⚠⚠⚠</p>
<p>在多人协作开发中，自己在改代码的时候一定要先<code>git pull origin master</code>对远程仓库的代码进行最新版同步后再自己修改，避免在自己修改之后<code>push</code>不上去。（如果实在是忘记了，应该可以有命令解决，解决方法在下文）</p>
<h2 id="当pull代码时出现报错，描述为：本地代码有修改，git不知道怎么办，你打算："><a href="#当pull代码时出现报错，描述为：本地代码有修改，git不知道怎么办，你打算：" class="headerlink" title="当pull代码时出现报错，描述为：本地代码有修改，git不知道怎么办，你打算："></a>当<code>pull</code>代码时出现报错，描述为：本地代码有修改，<code>git</code>不知道怎么办，你打算：</h2><p><img src="/2023/10/22/%E5%85%B6%E5%AE%83git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/%E5%BD%93%60pull%60%E4%BB%A3%E7%A0%81%E6%97%B6%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%EF%BC%8C%E6%8F%8F%E8%BF%B0%E4%B8%BA%EF%BC%9A%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%9C%89%E4%BF%AE%E6%94%B9%EF%BC%8C%60git%60%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%8A%9E.jpg" alt="当`pull`代码时出现报错，描述为：本地代码有修改，`git`不知道怎么办"></p>
<p>上图就是本地有修改后想<code>pull</code>远程仓库的代码下来，<code>git</code>的做法</p>
<h3 id="①放弃本地修改，直接照抄远程仓库代码"><a href="#①放弃本地修改，直接照抄远程仓库代码" class="headerlink" title="①放弃本地修改，直接照抄远程仓库代码"></a>①放弃本地修改，直接照抄远程仓库代码</h3><p>使用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将本地的<code>HEAD</code>指针指向了上一个版本，删除了暂存区（暂存区就是<code>add</code>到的地方）的内容，而且还删除了本地工作区的内容。</p>
</blockquote>
<p>简单来说就是将本地的<code>add</code>和<code>commit</code>全部撤销，并且清空工作区的内容，像是将<code>git</code>恢复到了上一级的“出厂设置”。</p>
<p>执行指令后，就会看到类似于这样一段话</p>
<blockquote>
<p>HEAD is now at 上一版本号 上一版本<code>commit</code>内容</p>
</blockquote>
<p>这样就是成功了！</p>
<p>之后正常<code>pull</code>就能成功了，之后就会出现下图的反馈<br><img src="/2023/10/22/%E5%85%B6%E5%AE%83git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/pull%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84%E5%8F%8D%E9%A6%88.jpg" alt="`pull`成功后的反馈"></p>
<h3 id="②保留本地修改，不要远程仓库的修改（即以本地为准）"><a href="#②保留本地修改，不要远程仓库的修改（即以本地为准）" class="headerlink" title="②保留本地修改，不要远程仓库的修改（即以本地为准）"></a>②保留本地修改，不要远程仓库的修改（即以本地为准）</h3><h3 id="③合并两者的修改，并将其中冲突处人工检测解决冲突"><a href="#③合并两者的修改，并将其中冲突处人工检测解决冲突" class="headerlink" title="③合并两者的修改，并将其中冲突处人工检测解决冲突"></a>③合并两者的修改，并将其中冲突处人工检测解决冲突</h3><h2 id="git-add-指令"><a href="#git-add-指令" class="headerlink" title="git add  _____ 指令"></a><code>git add  _____</code> 指令</h2><p><code>git add .</code>：将所有 <strong>修改过的 新增的</strong> 文件添加到暂存区，但是不会管<strong>被删除的</strong>文件。</p>
<p><code>git add -u</code>：即<code>git add -update</code>，只管被监控了的文件，就是将已经被<code>add</code>了的文件（即暂存区的文件）如果有修改，就会更新。所以它<strong>不会管新文件</strong>，因为新文件没有被监控。会管<strong>修改过的</strong>和<strong>删除的</strong>文件。</p>
<p><code>git add -a</code>：即<code>git add -all</code>，是上面两个<code>git</code>的集合，会提交所有<strong>被删除</strong>、<strong>被修改</strong>、和<strong>新增的</strong>文件到数据暂存区</p>
<p>PS：如何查看自己项目目录下的文件的状态？</p>
<blockquote>
<p>使用<code>git status</code>命令就可以，下面复制</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<h2 id="当你使用commit指令的时候发现自己手瘸，打错字了，你选择："><a href="#当你使用commit指令的时候发现自己手瘸，打错字了，你选择：" class="headerlink" title="当你使用commit指令的时候发现自己手瘸，打错字了，你选择："></a>当你使用<code>commit</code>指令的时候发现自己手瘸，打错字了，你选择：</h2><p>①再次使用<code>git commit -m &quot;这次争取打对字&quot; </code>。</p>
<p>恭喜你，获得<strong>报错</strong>一次，欸嘿嘿。</p>
<blockquote>
<p>当第一次使用<code>commit</code>指令的时候，本地的<code>git</code>认为你提交了你的修改记录，所以此时你的工作区已经被清空了，因为你本地已经提交成功了，此时没有修改，没有再次<code>add</code>，是不会让你再次<code>commit</code>的</p>
</blockquote>
<p>②打开网址 <a href="https://pi_haoxuan.gitee.io/2023/10/22/%E5%85%B6%E5%AE%83git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">其它git使用方法 | SPINNING PEN (gitee.io)</a> 找方法</p>
<p>再次恭喜你，选对了方法！！！</p>
<blockquote>
<p><code>git reset --soft HEAD~1</code>指令：撤销提交并保留更改在暂存区（即回退到<code>add</code>完成之后）</p>
<p><code>git reset --mixed HEAD~1</code>指令：撤销提交并取消更改（即回退到<code>add</code>完成之前）</p>
<p><code>git reset --hard HEAD~1</code>指令： 撤销提交并<strong>删除</strong>所有更改（即回退到文件修改之前，未修改状态，或者说上一次提交完成后的状态）</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>clash_for_windows</title>
    <url>/2023/10/19/clash-for-windows/</url>
    <content><![CDATA[<h1 id="科学上网！！"><a href="#科学上网！！" class="headerlink" title="科学上网！！"></a>科学上网！！</h1><span id="more"></span>

<p>分享一款科学上网的软件：clash for Windows</p>
<p>顾名思义，就是Windows操作系统下科学上网的工具</p>
<p>如果需要在mac上或者是在Linux上使用科学上网工具，也可以使用它的Linux版本和mac版本</p>
<p>以下就是下载链接了：</p>
<h3 id="下面三个都是Windows下的不同版本的clash"><a href="#下面三个都是Windows下的不同版本的clash" class="headerlink" title="下面三个都是Windows下的不同版本的clash"></a>下面三个都是Windows下的不同版本的clash</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Clash.for.Windows-0.20.19-ia32-win.7z">Clash for Windows 0.20.19英文版本</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Clash.for.Windows-0.20.21-win.7z">Clash for Windows 0.20.21英文版本</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Clash.for.Windows.Setup.0.20.38.exe">Clash for Windows 0.20.38且汉化版本</a></p>
<h3 id="在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash"><a href="#在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash" class="headerlink" title="在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash"></a>在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash</h3><h4 id="arm64架构"><a href="#arm64架构" class="headerlink" title="arm64架构"></a>arm64架构</h4><p><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.38/Clash.for.Windows-0.20.38-arm64-linux.tar.gz">Clash.for.Windows-0.20.38-arm64-linux版本</a></p>
<h4 id="x64架构"><a href="#x64架构" class="headerlink" title="x64架构"></a>x64架构</h4><p><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.38/Clash.for.Windows-0.20.38-x64-linux.tar.gz">Clash.for.Windows-0.20.38-x64-linux版本</a></p>
<h3 id="最后一个就是mac适用发clash了"><a href="#最后一个就是mac适用发clash了" class="headerlink" title="最后一个就是mac适用发clash了"></a>最后一个就是mac适用发clash了</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile2.0/Clash.for.Windows-0.20.38-arm64-mac.7z">Clash for mac 0.20.38版本</a></p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2023/10/09/git/</url>
    <content><![CDATA[<h1 id="一些关于远程git使用的心得"><a href="#一些关于远程git使用的心得" class="headerlink" title="一些关于远程git使用的心得"></a>一些关于<strong>远程git</strong>使用的心得</h1><span id="more"></span>

<p><strong>说明：本文使用Ubuntu20.04系统和gitee操作，理论上来说Windows系统和github的操作方法是一样的，只是有些路径不太一样。</strong></p>
<h3 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h3><p>首先需要有安装<code>git</code>（对于Windows平台来说，Linux应该是自带有git）</p>
<p>其次需要有gitee账号和一个新建的仓库</p>
<p>以上两项不会的自行查找资料，很简单的。(算了，我还是附上两（sì）个链接吧)</p>
<p><a href="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%7B%22request_id%22:%22169682895716800182799938%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169682895716800182799938&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115693833-null-null.142%5Ev95%5EchatgptT3_1&utm_term=git%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Windows下的Git 详细安装教程——详细到你不想看</a></p>
<p><a href="https://blog.csdn.net/m0_70102063/article/details/132166986?ops_request_misc=&request_id=&biz_id=102&utm_term=Linux%E4%B8%8B%E7%9A%84git%E5%AE%89%E8%A3%85&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-132166986.142%5Ev95%5EchatgptT3_1&spm=1018.2226.3001.4187">Linux系统上安装Git详细步骤</a></p>
<p><strong>gitee账号创建：对不起太简单了，找不到教程</strong></p>
<p><a href="https://blog.csdn.net/qq_73805125/article/details/130659347?ops_request_misc=%7B%22request_id%22:%22169683556316800215058913%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169683556316800215058913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-130659347-null-null.142%5Ev95%5EchatgptT3_1&utm_term=gitee%E8%B4%A6%E5%8F%B7%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA&spm=1018.2226.3001.4187">怎么在Gitee中创建仓库</a></p>
<h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><p><strong>第一步</strong>：初始化git</p>
<p>在需要git管理的项目文件夹中执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="/2023/10/09/git/init.jpg" alt="init"></p>
<p>再执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">la</span><br></pre></td></tr></table></figure>

<p>就可以看见<code>.git</code>文件夹，证明初始化成功</p>
<p><img src="/2023/10/09/git/la.jpg" alt="la"></p>
<p><strong>第二步</strong>：生成公钥以连接远程git仓库</p>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的gitee账号的主邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>如果之前执行过，或者连过远程仓库，那么会报错说已经有了密钥</p>
<p><img src="/2023/10/09/git/key_already_exists.jpg" alt="error"></p>
<p>如果没有过，那么<strong>注意</strong>：命令行会问你三个问题，别搭理他，直接回车让他尴尬就好了。之后会出现如图所示的奇怪图像</p>
<p><img src="/2023/10/09/git/key_ok.jpg" alt="key_succeed"></p>
<p>然后去<code>/root/.ssh</code>下找到三个文件：<code>id_rsa</code>、<code>id_rsa.pub</code>和<code>known_hosts</code>。其中<code>id_rsa</code>是私钥，注意藏好，不要外泄；<code>id_rsa.pub</code>就是公钥，这个就有大用了。</p>
<p>点开<code>id_rsa.pub</code>文件，将里面的东西全都复制（<code>ctrl + a</code> 全选，然后复制），打开你的<code>gitee</code>网站，点击你自己的可可爱爱的头像，找到设置，点击设置</p>
<p><img src="/2023/10/09/git/click_setting.jpg" alt="click_setting"></p>
<p>然后点击SSH公钥，输入标题，然后在公钥一栏种中粘贴刚刚复制的一堆东西</p>
<p><img src="/2023/10/09/git/add_pub_key.jpg" alt="add_pub_key"></p>
<p>确定然后验证密码，就好了</p>
<p><strong>如果是之前有公钥的，可能会显示已经添加过，可以直接对仓库进行读写，可以直接忽略，问题不大</strong></p>
<p><strong>第三步</strong>：建立账号连接</p>
<p>直接在命令行输入以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@git.oschina.net</span><br></pre></td></tr></table></figure>

<p>然后会显示啥呢？ 会和你问好，说你成功变成了作者balabala的，人还怪有礼貌的嘞！</p>
<p><img src="/2023/10/09/git/successfully.jpg" alt="successfully"></p>
<p>至此，就可以连接上你的**<code>gitee</code>账号<strong>了，但是！！！！</strong>仅仅是连接到了你的gitee账号，而非仓库**，你还不能像高手一样<code>clone</code>、<code>push</code>和<code>pull</code>。</p>
<p><strong>第四步</strong>：连接仓库，芜湖！</p>
<p>打开网页，进入你开头新建的仓库看右边有个<code>克隆/下载</code>的明显的按钮，点击，选择<code>http</code>然后点击复制，这样就把这个仓库的网址复制下来了（其实点击SSH也行）</p>
<p>然后在切回命令行那边（<strong>注意，我们一直是在你需要用<code>git</code>管理的文件路径下操作的</strong>）输入以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin 你刚刚复制的url地址</span><br></pre></td></tr></table></figure>

<p>然后检查一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/09/git/git_remote_-v.jpg" alt="git_remote_-v"></p>
<p>出现这个就是成功了！</p>
<blockquote>
<p>解释一下，其中origin不是一个指令参数，是一个别名，就是在之后的push和pull中，你的origin就代表着你的仓库的地址，也可以设计别的名字，比如小猫，小狗，大逼兜等等，当然最好是英文。</p>
</blockquote>
<p><strong>第五步</strong>：愉快地上传代码</p>
<p>终于来到了经典的<code>push</code>三连了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>第一条：将需要push的代码加载到工作区（本地）<code>.</code>的意思是本级目录下所有文件，也可以换成文件名或者路径</p>
<p>第二条：提交，但也是提交到本地，<code>message</code> 是你提交时候的备注，可以简要说明你做了啥，中英文都可以</p>
<p>第三条：将本地的东西全都<code>push</code>到远程仓库去，就是<code>gitee</code>上你创建的仓库。</p>
<blockquote>
<p>如果出现报错说你仓库有东西，两种解决方法</p>
<p><img src="/2023/10/09/git/push_error.jpg"></p>
<p>①先将仓库里的东西clone下来，修改后成你想要的之后再push上去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone origin</span><br></pre></td></tr></table></figure>

<p>②如果仓库的东西不要，直接在<code>gitee</code>网站上清空仓库（<strong>慎重</strong>）然后再<code>push</code>上去</p>
</blockquote>
<p><img src="/2023/10/09/git/push_succeed.jpg"></p>
<p>出现上图就是成功了。</p>
<p>再去<code>gitee</code>上看，代码也成功push上去了！</p>
<h3 id="圆满！！"><a href="#圆满！！" class="headerlink" title="圆满！！"></a>圆满！！</h3><p>PS:第一次push的时候会让你登录<code>gitee</code>，需要输入用户名和密码；用户名就是<code>gitee</code>的用户名,密码就是<code>gitee</code>账户的密码</p>
<p>如果之后每次提交都需要重复上述操作，挺烦的，那么就可以打开你项目文件夹的<code>.git/config</code>文件，<code>.get</code>就是开头说的那个文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin]</span><br><span class="line">url = https://gitee啥啥啥的</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">[remote &quot;origin]</span><br><span class="line">url = https://用户名:密码@gitee啥啥啥的</span><br></pre></td></tr></table></figure>

<p><strong>注意：以上所有符号用英文！</strong></p>
<p>END</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR</title>
    <url>/2023/09/17/OCR/</url>
    <content><![CDATA[<h1 id="初探OCR图片文字识别技术"><a href="#初探OCR图片文字识别技术" class="headerlink" title="初探OCR图片文字识别技术"></a>初探OCR图片文字识别技术</h1><span id="more"></span>

<p>图片文字识别 是 从一幅图片中通过一些算法，将图片中的文字识别提取出来。</p>
<p>通常图片中文字的检测分为比较简单的场景和比较复杂的场景</p>
<p><img src="/2023/09/17/OCR/%E7%AE%80%E5%8D%95%E5%9C%BA%E6%99%AF%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB.jpg" alt="简单场景文字识别"></p>
<p>简单场景文字识别</p>
<p><img src="/2023/09/17/OCR/%E5%A4%8D%E6%9D%82%E5%9C%BA%E6%99%AF%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB.jpg" alt="复杂背景文字识别"></p>
<p>复杂场景文字识别</p>
<p>对于简单场景文字识别，可以使用比较简单的两种方法：<strong>形态学操作法</strong> 和 <strong>MSER+NMS</strong>。</p>
<p>对于复杂场景的文字识别，则有<strong>CTPN</strong>、<strong>Seglink</strong> 和 <strong>EAST</strong> 三种主流方法。</p>
<h3 id="形态学操作法"><a href="#形态学操作法" class="headerlink" title="形态学操作法"></a>形态学操作法</h3><p>①先将图片灰度化，及转换为灰度图</p>
<p>②将图片降噪后进行二值化</p>
<p><img src="/2023/09/17/OCR/%E4%BA%8C%E5%80%BC%E5%8C%96%E5%90%8E.jpg"></p>
<p>③通过膨胀，腐蚀等方法突出文本框范围</p>
<p><img src="/2023/09/17/OCR/%E8%86%A8%E8%83%80%E5%90%8E.jpg" alt="膨胀后的图片"></p>
<p>④进行可信度分析，即判断哪些范围是不属于文本的</p>
<p>⑤得到文本范围的坐标</p>
<p><img src="/2023/09/17/OCR/%E5%9D%90%E6%A0%87.jpg"></p>
<h3 id="MSER-NMS"><a href="#MSER-NMS" class="headerlink" title="MSER+NMS"></a>MSER+NMS</h3>]]></content>
      <categories>
        <category>OCR</category>
      </categories>
      <tags>
        <tag>OCR</tag>
      </tags>
  </entry>
  <entry>
    <title>Class about Java and Qt</title>
    <url>/2023/07/21/Class%20about%20Java%20and%20Qt/</url>
    <content><![CDATA[<h1 id="This-is-a-passage-of-something-about-Qt-coding"><a href="#This-is-a-passage-of-something-about-Qt-coding" class="headerlink" title="This is a passage of something about Qt coding"></a>This is a passage of something about Qt coding</h1><span id="more"></span>

<h3 id="基于c-的Qt"><a href="#基于c-的Qt" class="headerlink" title="基于c++的Qt"></a>基于<code>c++</code>的<code>Qt</code></h3><p>在<code>Qt creator</code>中做<code>Qt</code>开发是基于<code>C++</code>的<code>Qt</code>开发，也即一种面向对象的<code>Qt</code>开发。</p>
<p>我是只学过<code>Java</code>，没学过<code>C++</code>的，于是与<code>Java</code>语言类比，发现了诸多类似与一些不同。</p>
<h3 id="关于Qt中的类"><a href="#关于Qt中的类" class="headerlink" title="关于Qt中的类"></a>关于<code>Qt</code>中的类</h3><p>在<code>Java</code>中，一个类可以拆解成（我所认为的）这么几部分：类名，成员变量和成员函数。</p>
<p>类名自然不用多说，切在类名后还可以实现继承和接口相关一些功能；成员变量和成员函数一起被一对<code>&#123;&#125;</code>包裹在类中。一般是先声明成员变量，再根据它们设计函数。</p>
<p>而在Qt中，需要在头文件中定义成员变量和声明成员函数，同时定义它们的作用范围，如下代码所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mainWidget.h 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mybutton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDING 2</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123; UP=<span class="number">0</span>, DOWN=<span class="number">1</span>, LEFT, RIGHT, LEFTTOP, LEFTBOTTOM, RIGHTBOTTOM, RIGHTTOP, NONE &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mainWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mainWidget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">mainWidget</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">region</span><span class="params">(<span class="type">const</span> QPoint &amp;currentGlobalPoint)</span></span>;  <span class="comment">//鼠标的位置,改变光标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QPoint m_movePoint;  <span class="comment">//鼠标的位置</span></span><br><span class="line">    <span class="type">bool</span> isLeftPressDown;  <span class="comment">// 判断左键是否按下</span></span><br><span class="line">    Direction dir;        <span class="comment">// 窗口大小改变时，记录改变方向</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//鼠标按下移动及释放事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWIDGET_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而成员函数的实现则在对应的<code>.cpp</code>文件中实现。</p>
<p>刚开始学<code>Qt</code>的时候，看到教程在不停的换文件编辑，觉得非常乱，了解这一点之后可以很清楚的知道什么内容要到什么文件中去编辑。</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2023/06/21/python/</url>
    <content><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><span id="more"></span>

<h3 id="python-安装环境"><a href="#python-安装环境" class="headerlink" title="python 安装环境"></a>python 安装环境</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/python-3.9.7-amd64.exe">python-3.9.7-amd64.exe</a></p>
<p>END</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>class17</title>
    <url>/2023/06/19/class17/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bec65e1f13de59763c066c00d2ba7e0320a2fe1298f896e00e27ee259c6cd4f1">042a9b5b09e3698fdc064d0eabb03174650f126803ba299425c6b1285a372b3b635c9b1093d087fb6abf3c04cca7c68e10c7dbe9d493bd51d500650489b430507616d4490cfa32abae95cc6baa570f300c10e84172f08cebedd1b0a692b6044ba09d0aa6b9e0f35ae6279f9ccb52ac914d6ae13023ce205a7622684227be473f9d8e0ecce6c15f59e3e05ff5041c393c2cf6cedbac9aedfd49a20879b5f1f4e90706b7e256388e224e6a5e6cc4f03206728a95f9ec68f6ade44666bb1f27c6aa97540549fd030c632834d029c0c61af3c96fdf268a80f0254bc6dc3bd58b54da2e4da22dc8604254684c328c9844ee88b62627de78485e237e1194868e42d0e94b7183240dfe380ff2dde7cb4e6bdc16f130c62a4fe49dfc020eda05da7399755a94f66bdb9ad2b7e16be1eee425555ec71ea037704124498d51102453476d69ab7cab9f39845e103a8f375abfe6d4bc75aedaa78bfa970af7be003447a6c8cee60ef5b28b235cb32016392f97ad56d99f13e55398bf4ce1ebdd339f097fec8a1d1389b504a1c575a82665eab04d2aafd2d87eb682da6ff5e68f9f06a27e66ecdde47a86496920a6c5545439f2c087d230a96b26eb986f51f3144f76dfb9ee28f512bb3fff2e9814a1294df17d5869c691c951855f1b733e9100d43ac86a1978378397e84ef66236ddfd5de30ff75007</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>高三17班</category>
      </categories>
      <tags>
        <tag>高三17班</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机指令解释</title>
    <url>/2023/06/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="简易编译器中的虚拟机指令解释"><a href="#简易编译器中的虚拟机指令解释" class="headerlink" title="简易编译器中的虚拟机指令解释"></a>简易编译器中的虚拟机指令解释</h1><span id="more"></span>

<h3 id="代码前定义"><a href="#代码前定义" class="headerlink" title="代码前定义"></a>代码前定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *src, *old_src;</span><br><span class="line"><span class="type">int</span> *bp, *sp, *pc; </span><br><span class="line"><span class="type">int</span> ax = <span class="number">0</span>; </span><br></pre></td></tr></table></figure>



<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> //枚举</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LEA,IMM,JMP,CALL,JZ,JNZ,ENT,ADJ,LEV,LI,LC,SI,SC,PUSH,OR,XOR,AND,EQ,NE,LT,GT,LE,GE,SHL,SHR,ADD,SUB,MUL,DIV,MOD,OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IMM"><a href="#IMM" class="headerlink" title="IMM"></a>IMM</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == IMM)</span><br><span class="line">&#123;</span><br><span class="line">	ax = *pc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IMM</code>指令用于将一个<code>数</code>存放在寄存器<code>ax</code>中。</p>
<p>其中<code>数</code>不一定是1，2，3，4等，可以是其它不同含义的数字，比如十六进制的<code>0xE4BDA0</code>在<code>utf-8</code>中表示中文字符<code>你</code>，也可以当作一个数存进寄存器<code>ax</code>中。</p>
<p><code>pc</code>指向的是下一个指令的地址，地址本质上也是一个数，即可以存储到寄存器<code>ax</code>中。</p>
<h3 id="LC"><a href="#LC" class="headerlink" title="LC"></a>LC</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LC)</span><br><span class="line">&#123;</span><br><span class="line">	ax = *(<span class="type">char</span> *)ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LC</code>指令用于将对应地址中的字符载入<code>ax</code>中。</p>
<p>执行指令前，<code>ax</code>中存放的是地址，一如IMM指令中所述，将该地址存放在<code>ax</code>中。现将<code>ax</code>中的地址强转为 <code>char *</code> （因为<code>ax</code>是<code>int</code>型） ，强转为<code>char * </code>只是告诉编译器，我下一次要取<code>ax</code>地址中对应的内容时，按照<code>char</code>的解析规则去解析，即随即而来的解引用操作，将<code>ax</code>中的地址值指向的内容，按照<code>char</code>的规则解析后，将其的编码（若是字母，则应该是ASCII码，如果是其它的字符，则是按照编码规则来存储的一些十六进制的码）存入<code>ax</code>中。</p>
<h3 id="LI"><a href="#LI" class="headerlink" title="LI"></a>LI</h3><p><code>LI</code>指令用于将对应地址中的整数载入<code>ax</code>中，和<code>LC</code>类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LI)</span><br><span class="line">&#123;</span><br><span class="line">    ax = *(<span class="type">int</span> *)ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SC"><a href="#SC" class="headerlink" title="SC"></a>SC</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SC)</span><br><span class="line">&#123;</span><br><span class="line">	ax = *(<span class="type">char</span> *)*sp++ = ax;<span class="comment">//sp++是压栈？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SC</code>指令用于将<code>ax</code>中的数据作为字符存放，且存放在栈顶。</p>
<p>首先POP一下，即<code>sp++</code>，然后将<code>ax</code>存放在<code>sp</code>指向的内存中。完成之后，将该地址强转为 <code>char *</code>类型，之后再按照<code>char</code>的规则取该地址中的内容，然后存入<code>ax</code>中。</p>
<p>简而言之，先将<code>ax</code>中的数存入<code>sp</code>栈顶中，然后将它转换成<code>char</code>类型，再更新<code>ax</code>中的值。</p>
<p>其实可以写成这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == SC)</span><br><span class="line">&#123;</span><br><span class="line">    *sp++ = ax;</span><br><span class="line">    ax = *(<span class="type">char</span> *)*sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SI"><a href="#SI" class="headerlink" title="SI"></a>SI</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SI)</span><br><span class="line">&#123;</span><br><span class="line">	*(<span class="type">int</span> *)*sp++ = ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>SC</code>类似，但是 是将<code>ax</code>中的数据以整数的形式重新存入<code>ax</code>中</p>
<h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == PUSH)</span><br><span class="line">&#123;</span><br><span class="line">	*--sp = ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PUSH</code>即为压栈，先开辟空间，即sp向下走一位，然后将<code>ax</code>的值写进去</p>
<h3 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JMP)</span><br><span class="line">&#123;</span><br><span class="line">	pc = (<span class="type">int</span> *)*pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JMP</code>的作用是跳转，即将<code>pc</code>指向的地址中的值改为下一块语句的地址。</p>
<blockquote>
<p><strong>注意</strong></p>
<p><code>JMP</code>是跳转到下一块，因为这是跳转，而不是按照顺序继续执行，中间必然是跳跃的一些代码的</p>
<p>若需要按顺序执行下一条语句，直接<code>pc++</code>就可以事项，在<code>JZ</code>和<code>JNZ</code>指令中有体现</p>
</blockquote>
<p><code>pc</code>中存放的是<strong>下一条指令的地址的地址</strong>，该操作是将下一条指令的地址直接赋给<code>pc</code>并以<code>int</code>规则解析该地址（因为<code>pc</code>本来就是<code>int *</code>类型）</p>
<h3 id="JZ"><a href="#JZ" class="headerlink" title="JZ"></a>JZ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JZ)</span><br><span class="line">&#123;</span><br><span class="line">	pc = ax ? pc + <span class="number">1</span> : (<span class="type">int</span> *)*pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JZ</code>：jump if ax is zero</p>
<p>即当<code>ax</code>为0时，使用<code>JZ</code>跳转到<code>(int *)*pc</code></p>
<h3 id="JNZ"><a href="#JNZ" class="headerlink" title="JNZ"></a>JNZ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JNZ)</span><br><span class="line">&#123;</span><br><span class="line">	pc = ax ? (<span class="type">int</span> *)*pc : pc + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JNZ</code>：jump if ax is not zero</p>
<p>即当<code>ax</code>不为0时，使用<code>JNZ</code>跳转到<code>(int *)*pc</code></p>
<h3 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == CALL)</span><br><span class="line">&#123;</span><br><span class="line">	sp--;</span><br><span class="line">	*sp = (<span class="type">int</span>)(pc + <span class="number">1</span>);</span><br><span class="line">	pc = (<span class="type">int</span> *)*pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CALL</code>用于调用子函数。</p>
<p>先将栈开辟一块空间，然后将顺序的下一句存进栈顶，然后实现一次<code>JMP</code>，跳转到子函数的地址。</p>
<blockquote>
<p>将顺序的下一句存入栈中，是因为等子函数执行完了之后，需要回过头来继续执行main函数</p>
</blockquote>
<h3 id="ENT"><a href="#ENT" class="headerlink" title="ENT"></a>ENT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ENT)</span><br><span class="line">&#123;</span><br><span class="line">	*--sp = (<span class="type">int</span>)bp;</span><br><span class="line">	bp = sp;</span><br><span class="line">	sp = sp - *pc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ENT</code>用于保存当前栈指针，然后分配一定空间给子函数运行</p>
<p>先调用基址指针<code>bp</code>来帮忙代替一下<code>sp</code>的工作：总是指向栈顶。在这之前需要在栈中保存基址指针指向的地址，即先分配空间保存<code>bp</code>的指向内容，然后将<code>sp</code>的值赋给<code>bp</code>，然后<code>sp</code>划分<code>*pc++</code>个空间给子函数运行。</p>
<blockquote>
<p><code>pc++</code>是<code>CALL</code>之后<code>pc</code>的顺序的下一个指令地址，里面存储了该函数需要多少空间才能保证顺利运行，所以编译器可以直接按照这个数字给子函数开辟内存</p>
</blockquote>
<h3 id="ADJ"><a href="#ADJ" class="headerlink" title="ADJ"></a>ADJ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ADJ)</span><br><span class="line">&#123;</span><br><span class="line">	sp = sp + *pc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ADJ</code>函数用于回收给子函数分配的空间。</p>
<h3 id="LEV"><a href="#LEV" class="headerlink" title="LEV"></a>LEV</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LEV)</span><br><span class="line">&#123;</span><br><span class="line">	sp = bp;</span><br><span class="line">	bp = (<span class="type">int</span> *)*sp++;</span><br><span class="line">	pc = (<span class="type">int</span> *)*sp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LEV</code>用于恢复没调用函数时的main函数的现场。</p>
<p>在<code>CALL</code>指令中，将顺序执行的下一条语句地址暂存，在<code>ENT</code>指令中，将基址指针<code>bp</code>的指向地址暂存，然后<code>bp</code>代替<code>sp</code>先指一会儿栈顶。</p>
<p>所以先将栈顶指针还给<code>sp</code>，然后带<code>bp</code>去找它之前指向的地址，然后把存该地址的空间消灭，接着就带<code>pc</code>去找顺序下一条语句的地址（因为中间插入的函数已经解决了），然后再将该空间消灭。</p>
<blockquote>
<p>先带<code>bp</code>，再带<code>pc</code>顺序不可乱，因为栈就是后进先出！！</p>
</blockquote>
<h3 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LEA)</span><br><span class="line">&#123;</span><br><span class="line">	ax = (<span class="type">int</span>)(bp + *pc++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LEA</code>指令用于取函数参数。</p>
<p><code>CALL</code>指令执行后，跳转至子函数执行，此时需要取子函数的参数。子函数的参数位置由基址指针<code>bp</code>和偏移量<code>*pc</code>决定，取完之后，将其存放到寄存器<code>ax</code>中</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>①在<code>JZ</code>和<code>JNZ</code>中，已经确定了两种情况下的<code>ax</code>为什么还需要用三目操作符来判断<code>ax</code>的值并给出相应的操作，且不管<code>ax</code>是否为0，结果都是一样的，即进行一次<code>JMP</code></p>
<p>②在<code>ENT</code>和<code>ADJ</code>中都涉及到了<code>*pc++</code>这个数值，但是在<code>ENT</code>分配的时候就已经调用了<code>*pc++</code>，理论上<code>pc</code>已经不再指向该函数需要的运行空间了，为什么在<code>ADJ</code>中还可以继续用<code>*pc++</code>来回收空间，此时的<code>pc</code>不应该指向其他值吗？</p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/06/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><span id="more"></span>



<h3 id="关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释："><a href="#关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释：" class="headerlink" title="关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释："></a>关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释：</h3><p>书中大部分代码使用头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrapper.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>在文件<code>wrapper.h</code>中，作者引用了大量的其他头文件，以及其他函数和作者对此书适应的定义，若没有该文件，此书中的很多代码编译运行的体验感不好。因此这里给出<code>wrapper.h</code>文件内容，及其使用方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* $begin wrapper.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WRAPPER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRAPPER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Default file permissions are DEF_MODE &amp; ~DEF_UMASK */</span></span><br><span class="line"><span class="comment">/* $begin createmasks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_MODE   S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_UMASK  S_IWGRP|S_IWOTH</span></span><br><span class="line"><span class="comment">/* $end createmasks */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Simplifies calls to bind(), connect(), and accept() */</span></span><br><span class="line"><span class="comment">/* $begin sockaddrdef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="comment">/* $end sockaddrdef */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Persistent state for the robust I/O (Rio) package */</span></span><br><span class="line"><span class="comment">/* $begin rio_t */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;                <span class="comment">/* descriptor for this internal buf */</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;               <span class="comment">/* unread bytes in internal buf */</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;          <span class="comment">/* next unread byte in internal buf */</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE]; <span class="comment">/* internal buffer */</span></span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br><span class="line"><span class="comment">/* $end rio_t */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  semaphore buffer structure */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">               <span class="type">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">               <span class="type">unsigned</span> <span class="type">short</span>  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">                                           (Linux-specific) */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* External variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;    <span class="comment">/* defined by BIND for DNS errors */</span> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">/* defined by libc */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MAXLINE	 8192  <span class="comment">/* max text line length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBUF   8192  <span class="comment">/* max I/O buffer size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ  1024  <span class="comment">/* second argument to listen() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our own error-handling functions */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ux_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">posix_error</span><span class="params">(<span class="type">int</span> code, <span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dns_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process control wrappers */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *iptr, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Getpgrp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Signal wrappers */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unix I/O wrappers */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">//#define Open(pathname, flags) Open(pathname, flags, 0666)</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">Lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Select</span><span class="params">(<span class="type">int</span>  n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Dup2</span><span class="params">(<span class="type">int</span> fd1, <span class="type">int</span> fd2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory mapping wrappers */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard I/O wrappers */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">FILE *<span class="title function_">Fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">Fgets</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">int</span> n, FILE *stream)</span>;</span><br><span class="line">FILE *<span class="title function_">Fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">Fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dynamic storage allocation wrappers */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">Realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">Calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sockets interface wrappers */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setsockopt</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">int</span> optlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">int</span> addrlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DNS wrappers */</span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">Gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">Gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *addr, <span class="type">int</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pthreads thread control wrappers */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tidp, <span class="type">pthread_attr_t</span> *attrp, </span></span><br><span class="line"><span class="params">		    <span class="type">void</span> * (*routine)(<span class="type">void</span> *), <span class="type">void</span> *argp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">Pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_function)())</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* POSIX semaphore wrappers */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rio (Robust I/O) package */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>; </span><br><span class="line"><span class="type">ssize_t</span>	<span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span>	<span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrappers for Rio package */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>; </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Client/server helper functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_client_sock</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">int</span> portno)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open_listen_sock</span><span class="params">(<span class="type">int</span> portno)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrappers for client/server helper functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Open_client_sock</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">int</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Open_listen_sock</span><span class="params">(<span class="type">int</span> port)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrappers for System V IPC functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgrcv</span><span class="params">(<span class="type">int</span> maqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">Shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, <span class="keyword">union</span> semun arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sem, <span class="type">int</span> sops)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __WRAPPER_H__ */</span></span></span><br><span class="line"><span class="comment">/* $end wrapper.h */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大家可以直接在文件夹中创建文件<code>wrapper.h</code>,然后编译。</p>
<p>如果此方法发不行，那么，按照下面方法来：</p>
<p>①下载附件：<a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/wrapper.zip">wrapper.h解决办法</a></p>
<p>②将附件中的除使用说明文件以外的四个文件复制，放入和需要该头文件的代码同一文件夹内。</p>
<p>③按照使用说明文件中的说明操作：</p>
<p>​	先执行下列命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rm libwrapper.a</span><br><span class="line">gcc  -c    wrapper.c  ptwrapper.c</span><br><span class="line">ar  rc  libwrapper.a  wrapper.o  ptwrapper.o</span><br></pre></td></tr></table></figure>

<p>​	都正常执行后，既可以编译需要编译的文件，编译文件时使用如下命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc yourfile.c -o yourfilename -L. -lwrapper</span><br></pre></td></tr></table></figure>

<p>​	既可以成功编译，生成二进制文件</p>
<h3 id="下面是实验时间！"><a href="#下面是实验时间！" class="headerlink" title="下面是实验时间！"></a>下面是实验时间！</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%88%E6%97%A0%E9%80%89%E5%81%9A%EF%BC%89.tar">lab4:进程间通信(无选做)</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/pihaoxuan_2021428010127_05.tar.zip">lab5:网络通信源代码</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2023/05/30/Vue/</url>
    <content><![CDATA[<h1 id="Vue前端开发"><a href="#Vue前端开发" class="headerlink" title="Vue前端开发"></a>Vue前端开发</h1><span id="more"></span>

<h3 id="实验三：投票系统的实现"><a href="#实验三：投票系统的实现" class="headerlink" title="实验三：投票系统的实现"></a>实验三：投票系统的实现</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Vue-lab3-vote-system.zip">实验三：投票系统的实现（npm组件工程项目）</a></p>
]]></content>
      <categories>
        <category>Vue前端开发</category>
      </categories>
  </entry>
  <entry>
    <title>数据库原理</title>
    <url>/2023/05/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="数据库系统原理实验-amp-amp-作业"><a href="#数据库系统原理实验-amp-amp-作业" class="headerlink" title="数据库系统原理实验&amp;&amp;作业"></a>数据库系统原理实验&amp;&amp;作业</h2><span id="more"></span>



<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A2%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0.docx">作业二：数据操作语言：SQL</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A%E4%B8%89.docx">作业三：数据库安全性、数据库完整性</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A5%EF%BC%9A%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%AC%E5%8D%81%E7%AB%A0.docx">作业五：数据库编程，并发控制与恢复</a></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E5%AD%A6%E7%94%9F%E9%80%89%E8%AF%BE%E6%88%90%E7%BB%A9-csv%E8%A1%A8%E6%A0%BC-%E5%8F%AF%E5%AF%BC%E5%85%A5workbanch.zip">前两次实验数据包，可直接导入workbanch</a></p>
<h3 id="数据库系统原理实训大作业"><a href="#数据库系统原理实训大作业" class="headerlink" title="数据库系统原理实训大作业"></a>数据库系统原理实训大作业</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%8B%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%AE%AD.zip">综合实训相关题目和实训报告</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E9%9B%B6%E5%94%AE%E9%9B%86%E5%9B%A2%E5%95%86%E5%93%81%E9%87%87%E8%B4%AD-%E5%AE%9E%E8%AE%AD%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E8%87%AA%E5%88%B6%EF%BC%89.zip">零售集团商品采购数据包</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E9%9B%B6%E5%94%AE%E9%9B%86%E5%9B%A2%E5%95%86%E5%93%81%E9%87%87%E8%B4%ADER%E5%9B%BE%EF%BC%88%E8%87%AA%E7%BB%98%EF%BC%89.jpg">零售集团商品采购ER图</a></p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title>关于C语言char读入中文</title>
    <url>/2023/05/28/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80char%E8%AF%BB%E5%85%A5%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h2 id="关于C语言char读入中文"><a href="#关于C语言char读入中文" class="headerlink" title="关于C语言char读入中文"></a>关于C语言char读入中文</h2><span id="more"></span>

<p>先上代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">char</span> *src;</span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上述代码所示，其中<code>token</code>是<code>int</code>类型，而<code>src</code>是<code>char</code>类型的指针，它所指向的内容只会取一个字节进行解析。</p>
<p>现在让<code>src</code>指向一个内存块，其存储的值是<code>0xE4BDA0</code>，即中文字符<code>你</code>的<code>utf-8</code>的编码，由于你的编码占了三个字节，而C语言中<code>char</code>类型只解析一个字节，因此，当<code>src</code>指向这个内存块的时候，只解析最低位，即<code>0xA0</code>。当讲0xA0赋值给token时，因为token是int类型，因此token会将最低位写入0xA0，其它位保持赋值时刷新的值。</p>
<blockquote>
<p>解释一下<code>保持赋值时刷新的值</code>是什么意思：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line">k=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，k被赋值三，且之前没初始化，那么在赋值时，为了保证k 的正确，应该将对应的内存刷新成二进制</p>
<p><code>0000 0000 0000 0011</code>但是在计算机内部，整数是用补码存储的，因此在计算机中，真实的值应该是</p>
<p><code>0111 1111 1111 1101</code>因为k是int类型，不是无符号，所以第一位仍然是0，表示该数是正数。</p>
</blockquote>
<p>所以，在将0xA0赋值给int时，会经历这样一个过程：</p>
<blockquote>
<p>①判断0xA0在char中是负数：<code>1010 0000</code> 首位是1，判断为负数</p>
<p>②赋值时，计算机为了保证正确性，先将token定义为负数，即首位为1</p>
<p>③确定正负后，将值写入。</p>
</blockquote>
<p>所以token在计算机内部应该是 <code>1111 1111 1111 1010 0000</code> 这是补码形式，转换成真实值就是</p>
<p> <code>1000 0000 0000 0110 0000</code> 所以输出就是<code>-96</code>。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><span id="more"></span>

<h3 id="计算机网络作业四：网络层"><a href="#计算机网络作业四：网络层" class="headerlink" title="计算机网络作业四：网络层"></a>计算机网络作业四：网络层</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A4.pdf">戳我下载！！</a></p>
<h3 id="计算机网络实验四：网际控制报文协议ICMP分析"><a href="#计算机网络实验四：网际控制报文协议ICMP分析" class="headerlink" title="计算机网络实验四：网际控制报文协议ICMP分析"></a>计算机网络实验四：网际控制报文协议ICMP分析</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP%E5%88%86%E6%9E%90.docx">怼我下载计网实验四：网际控制报文协议ICMP分析</a></p>
<h3 id="计算机网络作业五：传输层"><a href="#计算机网络作业五：传输层" class="headerlink" title="计算机网络作业五：传输层"></a>计算机网络作业五：传输层</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A5.pdf">戳我下载！</a></p>
<h3 id="思政作业3"><a href="#思政作业3" class="headerlink" title="思政作业3"></a>思政作业3</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E6%94%BF%E4%BD%9C%E4%B8%9A3.docx">阅读参考《中国互联网络发展状况统计报告（第51次）》有关内容</a></p>
<h3 id="作业6：应用层"><a href="#作业6：应用层" class="headerlink" title="作业6：应用层"></a>作业6：应用层</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E4%BD%9C%E4%B8%9A6.pdf">作业6666666666：应用层</a></p>
<h3 id="实验六：超文本传送协议HTTP分析"><a href="#实验六：超文本传送协议HTTP分析" class="headerlink" title="实验六：超文本传送协议HTTP分析"></a>实验六：超文本传送协议HTTP分析</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEHTTP%E5%88%86%E6%9E%90.docx">点我，解锁更多* * *%@#&amp;￥%！@￥%……@#￥</a></p>
<h3 id="实验七：web页面请求全历程协议及数据包解析"><a href="#实验七：web页面请求全历程协议及数据包解析" class="headerlink" title="实验七：web页面请求全历程协议及数据包解析"></a>实验七：web页面请求全历程协议及数据包解析</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E4%B8%83%EF%BC%9Aweb%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E5%85%A8%E5%8E%86%E7%A8%8B%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90.docx">嘿 嘿嘿 嘿嘿嘿 你懂的</a></p>
<p>END</p>
]]></content>
      <categories>
        <category>计网作业</category>
      </categories>
  </entry>
  <entry>
    <title>C语言解释</title>
    <url>/2023/05/22/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>关于C语言中一些系统定义的解释</p>
<span id="more"></span>

<h3 id="perror-char"><a href="#perror-char" class="headerlink" title="perror( char )"></a>perror( char )</h3><blockquote>
<p>作用：输出错误信息</p>
<p>参数解释：传入字符串，例如<code>perror(&quot;upper&quot;)</code></p>
<p>标准输出：<code>upper: error message</code> 其中error message 是系统定义的错误信息</p>
<p>在写代码是可以适当使用该函数，用来调试程序，函数会指出错误原因</p>
</blockquote>
<h3 id="stderr"><a href="#stderr" class="headerlink" title="stderr"></a>stderr</h3><blockquote>
<p>作用：输出文件处理时候的错误信息</p>
<p>注意：这个不是函数，而是一个指针，类型为<code>FILE*</code>，作为<code>fprintf</code>中的第一个参数使用，后接错误信息</p>
<p><code>code01</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> err_code = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error occurred, error code is %d\n&quot;</span>, err_code);</span><br><span class="line">  <span class="keyword">return</span> err_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该参数只处理文件操作错误的信息</p>
</blockquote>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><blockquote>
<p>作用：C语言中的一个关键词，用于修饰一个函数，放在函数返回类型前。</p>
<p>被修饰的函数称为“<code>内联函数</code>”，通常是一个小巧的，轻量级的函数，定量来看，一般不超过10行。</p>
<p>注意：函数中应该不包括<code>递归</code>、<code>循环</code>等“非轻量级”的操作，或者是一些本身就很复杂的库函数中的函数调用。</p>
<p>作为函数，肯定是常用的，才会封装成一个函数，使得代码简洁，但是这个<code>inline函数</code>看起来好像没啥实际上的作用，那为什么还要用这个关键词修饰呢？</p>
<p>深层内涵：<code>inline</code>函数在编译的时候，会出现在任何一个调用它的地方，并且以内容的形式出现，而不是以跳转地址的形式出现，即函数执行到了调用<code>inline</code>函数的时候，并不需要跳转寻址来另外开栈执行函数，然后再跳转回去继续执行；而是直接将函数内容嵌入调用<code>inline</code>函数的地方，让程序直接往下执行，举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%D&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    add(a,b);</span><br><span class="line">    add(m,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简单的加法函数，在<code>main</code>函数中调用了<code>add</code>函数，但是在编译过后，它完全等价于下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c = a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">    <span class="type">int</span> d = m+n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将函数以内容的方式呈现在<code>main</code>函数中，而不是以地址跳转的方式去调用函数。</p>
<p>好处：这样一个关键词的存在不仅满足了代码的简洁性和可读性，还可以增加代码的编译速度，在编译和执行的过程中不必另开空间去编译执行。但是如果<code>inline</code>修饰稍稍复杂一点的函数，那会导致汇编代码太长，反而减慢了编译执行的速度，适得其反。所以<code>inline</code>函数只能修饰轻量级函数，而不修饰复杂函数。简而言之<strong>复杂不了一点</strong>。</p>
</blockquote>
<h3 id="strcmp和strncmp"><a href="#strcmp和strncmp" class="headerlink" title="strcmp和strncmp"></a><code>strcmp</code>和<code>strncmp</code></h3><blockquote>
<p>共同点：两者都是比较两个字符串，判断<code>str2</code>是否存在于<code>str1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncmp</span>(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> n)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>strncmp</code>多了一个参数<code>n</code>，用于限定比较字符的长度，在限定长度内如果相等，则返回<code>0</code>以表示相等，否则返回下标为<code>n</code>的两个字符串的差（str1[n] - str2[n]）</p>
<p>而<code>strcmp</code>是两个字符串全部相等才会返回<code>0</code></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2); <span class="comment">//判断结果为不相等</span></span><br><span class="line"><span class="built_in">strncmp</span>(str1,str2,<span class="number">4</span>); <span class="comment">//判断结果为相等</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="stat结构体和stat函数"><a href="#stat结构体和stat函数" class="headerlink" title="stat结构体和stat函数"></a><code>stat</code>结构体和<code>stat</code>函数</h3><blockquote>
<p><code>stat</code>结构体：存储文件信息的一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__dev_t</span> st_dev; <span class="comment">/* Device.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> __pad1;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__ || !defined __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">__ino_t</span> st_ino; <span class="comment">/* File serial number.	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__ino_t</span> __st_ino; <span class="comment">/* 32bit file serial number.	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x86_64__</span></span><br><span class="line">    <span class="type">__mode_t</span> st_mode;   <span class="comment">/* File mode.  */</span></span><br><span class="line">    <span class="type">__nlink_t</span> st_nlink; <span class="comment">/* Link count.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__nlink_t</span> st_nlink; <span class="comment">/* Link count.  */</span></span><br><span class="line">    <span class="type">__mode_t</span> st_mode;   <span class="comment">/* File mode.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">__uid_t</span> st_uid; <span class="comment">/* User ID of the file&#x27;s owner.	*/</span></span><br><span class="line">    <span class="type">__gid_t</span> st_gid; <span class="comment">/* Group ID of the file&#x27;s group.*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">    <span class="type">int</span> __pad0;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">__dev_t</span> st_rdev; <span class="comment">/* Device number, if device.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> __pad2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__ || !defined __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">__off_t</span> st_size; <span class="comment">/* Size of file, in bytes.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__off64_t</span> st_size; <span class="comment">/* Size of file, in bytes.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">__blksize_t</span> st_blksize; <span class="comment">/* Optimal block size for I/O.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__ || !defined __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">__blkcnt_t</span> st_blocks; <span class="comment">/* Number 512-byte blocks allocated. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__blkcnt64_t</span> st_blocks; <span class="comment">/* Number 512-byte blocks allocated. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K8</span></span><br><span class="line">    <span class="comment">/* Nanosecond resolution timestamps are stored in a format</span></span><br><span class="line"><span class="comment">       equivalent to &#x27;struct timespec&#x27;.  This is the type used</span></span><br><span class="line"><span class="comment">       whenever possible but the Unix namespace rules do not allow the</span></span><br><span class="line"><span class="comment">       identifier &#x27;timespec&#x27; to appear in the &lt;sys/stat.h&gt; header.</span></span><br><span class="line"><span class="comment">       Therefore we have to handle the use of this header in strictly</span></span><br><span class="line"><span class="comment">       standard-compliant sources special.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>    <span class="comment">/* Time of last access.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>    <span class="comment">/* Time of last modification.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>    <span class="comment">/* Time of last status change.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec <span class="comment">/* Backward compatibility.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__time_t</span> st_atime;              <span class="comment">/* Time of last access.  */</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> st_atimensec; <span class="comment">/* Nscecs of last access.  */</span></span><br><span class="line">    <span class="type">__time_t</span> st_mtime;              <span class="comment">/* Time of last modification.  */</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> st_mtimensec; <span class="comment">/* Nsecs of last modification.  */</span></span><br><span class="line">    <span class="type">__time_t</span> st_ctime;              <span class="comment">/* Time of last status change.  */</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> st_ctimensec; <span class="comment">/* Nsecs of last status change.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">    <span class="type">__syscall_slong_t</span> __glibc_reserved[<span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __glibc_reserved4;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __glibc_reserved5;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__ino64_t</span> st_ino; <span class="comment">/* File serial number.	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中常用的属性段有</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">st_mode：文件类型和权限位</span><br><span class="line">st_ino：文件的i-node号</span><br><span class="line">st_dev：文件所在设备的ID</span><br><span class="line">st_nlink：链接数</span><br><span class="line">st_uid：文件所有者的用户ID</span><br><span class="line">st_gid：文件所有者的组ID</span><br><span class="line">st_size：文件大小（字节数）</span><br><span class="line">st_atime：最后一次访问时间</span><br><span class="line">st_mtime：最后一次修改时间</span><br><span class="line">st_ctime：最后一次改变时间（通常是文件元数据改变的时间）</span><br></pre></td></tr></table></figure>

<p>可以极简单地获取文件信息</p>
<p><code>stat</code>函数：用于获取给定路径下的文件的信息，并存储在一个<code>stat</code>结构体中，返回值为<code>int</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get file attributes for FILE and put them in BUF.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">stat</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __file,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> stat *__restrict __buf)</span> __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若成功获取文件信息，则返回<strong>0</strong> 否则返回<strong>1</strong></p>
</blockquote>
<h3 id="va-list、va-start、va-arg、va-end函数"><a href="#va-list、va-start、va-arg、va-end函数" class="headerlink" title="va_list、va_start、va_arg、va_end函数"></a><code>va_list</code>、<code>va_start</code>、<code>va_arg</code>、<code>va_end</code>函数</h3><blockquote>
<p><code>va_list</code>：可以理解为一种新类型，类似于<code>int</code>。实例化一个类似于<code>list</code>的东西，但是名字是<code>va_list</code>。</p>
<p><code>va_start</code>：函数使用：<code>va_start(va_list n, paramN)</code>。</p>
<p>初始化一个<code>va_list</code>实例，<code>paramN</code>可以是任意参数，即初始化<code>n</code>以检索参数<code>paramN</code>以后的参数，通常<code>paramN</code>是指<code>paramN</code>之后的参数个数</p>
<p><code>va_arg</code>：函数使用：<code>va_arg(va_list n , T)</code></p>
<p>获取va_list n 中的<code>T</code>类型的参数，通常是从<code>paramN</code>之后的一个参数开始获取的（包含<code>paramN</code>之后的那个参数，但不包括<code>paramN</code></p>
<p>va_end：函数使用：va_end(va_list n)</p>
<p>释放<code>va_list n</code></p>
<p>函数示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明，可以传入任意多个参数，但第一个参数必须是int</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//3个int相加，分别是 15， 56， 4</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Sum = %d\n&quot;</span>,  sum(<span class="number">3</span>, <span class="number">15</span>, <span class="number">56</span>,<span class="number">4</span>) );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num_args, ...)</span> &#123;</span><br><span class="line">   <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例化一个va_list ap</span></span><br><span class="line">   va_list ap;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   va_start(ap, num_args);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_args; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i:%d\n&quot;</span>,i);</span><br><span class="line">    <span class="comment">//获取第一个int参数（是除了paramN之后的第一个，在本函数中也就是num_args后面的一个参数）</span></span><br><span class="line">    <span class="comment">//如果有参数不是int，则自动获取下一个，但是如果后面没有参数了，就会获取随机值</span></span><br><span class="line">    s=va_arg(ap,<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;va_arg(ap,int):%d\n&quot;</span>,s);</span><br><span class="line">       </span><br><span class="line">     <span class="comment">//累加</span></span><br><span class="line">     val += s;</span><br><span class="line">   &#125;</span><br><span class="line">   va_end(ap);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述函数中，需要用s变量承接va_arg(ap,int)是因为va_arg函数每调用一次，获取玩当前的值后会自动往后走，下次调用的时候可以直接获取，然后再往下走。</span></span><br></pre></td></tr></table></figure>

<p>说明：这四个通常是一套组合拳，而且用于自定义的函数中，通常不作为单独的函数被调用，而是处理自定义的函数传入的参数。</p>
<p>例如，上述例子中，定义的<code>sum</code>函数，可以接收任意多个参数，于是就是用这一套组合拳，处理这任意多的参数。</p>
<p>值得一提的是，<code>va_arg()</code>函数是处理任意多参数的关键，它能获取<code>sum</code>函数中第一个参数之后的所有参数（调用一次获取一次，并自动会跳到下一个参数【如果没有下一个，就是随机值】），并自动识别停止。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>编译学习-虚拟机部分--20230518</title>
    <url>/2023/05/18/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E5%88%86-20230518/</url>
    <content><![CDATA[<h1 id="编译学习虚拟机部分"><a href="#编译学习虚拟机部分" class="headerlink" title="编译学习虚拟机部分"></a>编译学习虚拟机部分</h1><span id="more"></span>

<h3 id="1、支撑知识"><a href="#1、支撑知识" class="headerlink" title="1、支撑知识"></a>1、支撑知识</h3><h4 id="关于电脑内存"><a href="#关于电脑内存" class="headerlink" title="关于电脑内存"></a>关于电脑内存</h4><p>电脑中的内存是虚拟地址映射到实际的内存上，而非真是有这么多。</p>
<h4 id="关于本次使用的内存段"><a href="#关于本次使用的内存段" class="headerlink" title="关于本次使用的内存段"></a>关于本次使用的内存段</h4><p>简单来讲，进程的内存会被分为以下几个段</p>
<blockquote>
<p>1.代码段（text），用于存放指令代码，位于较低地址。（可能是指令需要改动不多甚至不需要改动，放在一些低地址区域，该区域可能是只读的）</p>
<p>2.数据段（data），用于存放<strong>已经初始化的数据</strong>，例如<code>int i = 10</code>就是已经初始化的数据，需要存储到改位置。</p>
<p>3.未初始化数据段（bss），顾名思义，就是存放<strong>未初始化的数据</strong>的地方，例如<code>int i[1000]</code>就是属于只声明而未初始化的数据，存放在该段。</p>
<p>4.堆（heap），用于为程序动态分配内存。</p>
<p>5.栈（stack）用于处理函数调用的相关数据，例如调用帧或者函数的局部变量。</p>
</blockquote>
<p>在第一点中提到在代码段在内存中位于低地址区域，那么如下图所示：</p>
<p><code>图一</code></p>
<p><img src="/2023/05/18/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E5%88%86-20230518/%E5%9C%B0%E5%9D%80%E5%88%86%E5%B8%83.jpg" alt="各部分地址分布"></p>
<p>个人理解：在计算机内存中，低地址是不允许写入的，其中存放的数据都是一些系统级的或者是常量，例如数字（0-9），字符（a-zA-Z,.&#x2F;等），当程序需要时，就只能读取而不能写入。</p>
<p>而在高地址字段，例如堆栈，可以实现内存的动态分配和数据的调用和修改，即可读可写，提高了与用户的交互性。</p>
<p>为简单起见，本次只关心 <strong>①代码段 ②数据段 ③栈</strong></p>
<h4 id="③寄存器"><a href="#③寄存器" class="headerlink" title="③寄存器"></a>③寄存器</h4><p>寄存器用于存放计算机的运行状态，真实计算机中有许多寄存器，本次只用4种。</p>
<blockquote>
<p>1.<code>PC（Program Counter）程序计数器</code> 存放内存地址，该地址中放着<strong>下一条</strong>要执行的计算机指令</p>
<p>2.<code>SP（Stack Pointer）指针寄存器</code> 永远指向当前栈的栈顶。因为栈顶是由高地址扩张到低地址（可以参考图一，栈底在最顶端）所以当有数据入栈时，SP的地址值减小；当出栈时SP的地址值增大</p>
<p>3.<code>BP（Base Pointer）基址指针</code> 也是用于指向栈的某些位置（不想确定的位置，也并不是不能指向栈顶）</p>
<p>4.<code>AX（Accumulator Register）通用寄存器</code> 从英文上看出是累加寄存器，在虚拟机中，用于存放一条指令执行后的计算结果。</p>
<p><strong>PS：前三个都是存放地址的，定义是要指针定义，而AX是存放结果的，不用定义成指针。在实际计算机中，PC的初始值应该指向main函数的地址，但是现在 还没到这一步，先不指定。</strong></p>
</blockquote>
<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可不可以用unsigned int？？？</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><h4 id="类型问题"><a href="#类型问题" class="headerlink" title="类型问题"></a>类型问题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LC)   &#123;ax = *(<span class="type">char</span> *)ax;&#125;      <span class="comment">// load character to ax, address in ax</span></span><br></pre></td></tr></table></figure>

<p>if中的操作是将ax中的值作为地址，并且按照char类型解析该地址指向的内容，然后将解析完后的char重新赋值给ax，应该会导致类型冲突的呀。</p>
<blockquote>
<p><strong>解答</strong>：在计算机内存中，不论是<code>int</code>还是<code>char</code>还是各种指针类型，其实都是一个数，而<code>int</code>，<code>char</code>或者是<code>int*</code>，<code>char*</code>是决定程序在解析这个数的时候的方式（往后读多少个内存单元，按照什么类型解析）。</p>
<p>改代码中，如果ax不是很大的数（8位以内），可以正常运行，再大就会出现转换错误的情况。</p>
</blockquote>
<h4 id="sp-sp-pc"><a href="#sp-sp-pc" class="headerlink" title="sp = sp - *pc++"></a><code>sp = sp - *pc++</code></h4><p>将栈顶指针sp 减去下一个指令需要使用的空间大小，pc++是指下一个指令的地址，解引用后就是指下一个指令，同时是一个int值，为什么指的是下一个指令所需要的空间大小？</p>
<blockquote>
<p><strong>解答</strong>：在函数调用时，一个函数需要多大的空间运行，一般都会在函数内部用一个小空间存储这个内容。</p>
<p>这里将这个内容取出来减去，就是回收之前为子函数开辟出来的子函数提前告知的需要的空间。</p>
</blockquote>
<h3 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h3><h4 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h4><p><code>int * </code>和<code>char *</code>本质上都是指针，而指针都是一个数字，而计算机内指针都是用数字表示的，为什么不统一用int或者是unsigned int，而是要分int char和其它？</p>
<p>因为<code>int * </code>和<code>char *</code>指向的数字表示不同的数据类型，而且还是做指针运算时的重要依据，比如在int类型中，指针运算++是向后移动4个字节（大多数机器是这样的），而char类型在做指针运算时，往往只向后移动1个字节，计算机做出这样的依据就是所使用的指针类型。</p>
<p>其次，在计算机编译阶段，这两种类型对应存储的数据需要不同，计算机在编译时会检查<code>int * </code>和<code>char *</code>所指向的数据是否正确，若不正确则报错，避免潜在的错误。</p>
<p>GPT这样说：</p>
<blockquote>
<p>int *和char *在本质上的区别是指针所指向内存单元中存储的数据类型不同。</p>
<p>int * 是一个指向整型变量的指针，它所指向的内存单元中存储的是一个整型数值，占用 4 字节（在大部分机器上）。而 char * 则是一个指向字符型变量的指针，它所指向的内存单元中存储的是一个字节大小的 ASCII 码或者 Unicode 码。</p>
<p>在计算机编译时，int <em>和char * 在指针操作上会有所不同。在执行指针运算时，指针所指向的内存单元地址将根据数据类型的不同而发生改变。例如，对于一个 int</em> 指针变量 p，执行 p++ 操作时，p 的值将增加 4，因为一个 int 变量占用 4 个字节。而对于一个 char* 指针变量 q，执行 q++ 操作时，q 的值只会增加 1，因为一个 char 变量只占用一个字节。</p>
<p>此外，在编译器生成目标代码时，对于 int * 和 char * 所指向的内存单元，编译器在生成代码时还会进行类型检查。这是为了确保程序不会访问不正确的内存地址，避免潜在的错误。例如，在使用 int * 指针时，我们只能访问整型变量的内存地址，不能访问 char 或其他类型变量的内存地址。</p>
</blockquote>
<h4 id="关于栈顶"><a href="#关于栈顶" class="headerlink" title="关于栈顶"></a>关于栈顶</h4><p><code>SP指针寄存器</code> 永远指向当前栈的栈顶  此处的栈顶是最顶端的元素，而非最顶端元素的上面一个。</p>
<h4 id="一些骚操作"><a href="#一些骚操作" class="headerlink" title="一些骚操作"></a>一些骚操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SC)   &#123;ax = *(<span class="type">char</span> *)*sp++ = ax;&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的运算顺序是：</p>
<p>①sp++申请新空间</p>
<p>②*解引用</p>
<p>③将ax的值存进去</p>
<p>④char * 强转</p>
<p>⑤*解引用</p>
<p>⑥将值再赋给ax（如果ax中的数字小的话，其实没变）</p>
<h4 id="pc-1和-int-pc"><a href="#pc-1和-int-pc" class="headerlink" title="pc+1和(int *)*pc"></a><code>pc+1</code>和<code>(int *)*pc</code></h4><p><code>pc = pc+1</code>是指顺序执行下一行代码（从上帝视角来看）</p>
<p><code>pc = (int *) *pc</code>是指跳转到下一个语句块</p>
<p>从JMP指令的实现是<code>pc = (int *) *pc</code>就能看出，如果if后面是0，那么则回执行<code>pc = (int *) *pc</code>，实质上是进行了一次JMP。</p>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译设计</title>
    <url>/2023/05/12/%E7%BC%96%E8%AF%91%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="着手设计"><a href="#着手设计" class="headerlink" title="着手设计"></a>着手设计</h1><span id="more"></span>

<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>学习<strong>手把手教你构建C语言编译器–设计</strong>部分</p>
<p><a href="https://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）- 设计 </a></p>
<p>试写了文章中的代码，虽然成功了，但是有点问题。</p>
<h4 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h4><p>编写一个编译器一般为<strong>①词法分析器；②语法分析器；③目标代码生成</strong>。以下为手写这些构成部分。</p>
<p>一个编译器的框架首先是有</p>
<blockquote>
<p>编译器包含四个函数：</p>
<p>1、next()函数，用于读取下一个标记，会自动忽略掉空格；	&#x2F;&#x2F;读程序</p>
<p>2、program()函数，语法分析的入口，分析整个程序。本部分不写；	&#x2F;&#x2F;做语法分析</p>
<p>3、expression(level)函数，用于解析一个表达式。本部分不写；	&#x2F;&#x2F;做语义分析</p>
<p>4、eval()函数，虚拟机接口，可以解释目标代码。</p>
</blockquote>
<h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><p>以下是代码块，和教程上的代码一模一样，，，，，</p>
<p><code>code01</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">char</span> *src, *old_src;</span><br><span class="line"><span class="type">int</span> poolsize;</span><br><span class="line"><span class="type">int</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取src中下一个字符的ASCII码值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式分析pewpwd</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expression</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件，直到token小于0（因为token是ASCII，所以没有小于0 的情况，等于0就是结束符）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    next(); <span class="comment">// get next token</span></span><br><span class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;token is: %c\n&quot;</span>, token);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机接口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eval</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">// do nothing yet</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    poolsize = <span class="number">256</span> * <span class="number">1024</span>; <span class="comment">// arbitrary size</span></span><br><span class="line">    line = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(*argv, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;could not open(%s)\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(src = old_src = <span class="built_in">malloc</span>(poolsize)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;could not malloc(%d) for source area\n&quot;</span>, poolsize);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the source file</span></span><br><span class="line">    <span class="keyword">if</span> ((i = read(fd, src, poolsize - <span class="number">1</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read() returned %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src[i] = <span class="number">0</span>; <span class="comment">// add EOF character</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h4><p>①第三行 include 的 memory.h 好像没用到（可能之后会用到吧）</p>
<p>②第52行，open函数中的参数，第一个参数是取用户输入的第一个参数，但是第二个参数不理解。</p>
<p>翻看了函数原型，代码如下：</p>
<p><code>code02</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__fortify_function <span class="type">int</span></span><br><span class="line"><span class="title function_">open</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__path, <span class="type">int</span> __oflag, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__va_arg_pack_len () &gt; <span class="number">1</span>)</span><br><span class="line">    __open_too_many_args ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p (__oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__OPEN_NEEDS_MODE (__oflag) &amp;&amp; __va_arg_pack_len () &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  __open_missing_mode ();</span><br><span class="line">	  <span class="keyword">return</span> __open_2 (__path, __oflag);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">return</span> __open_alias (__path, __oflag, __va_arg_pack ());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__va_arg_pack_len () &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> __open_2 (__path, __oflag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __open_alias (__path, __oflag, __va_arg_pack ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是int类型没错，但是具体含义不知道。</p>
<p>上网查后，解释是，第二个参数代表对该文件的操作权限，例如：只读，只写，读写。但是很神奇，这些权限的表示方法如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">flags 参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O_RDONLY</td>
<td align="center">只读模式</td>
</tr>
<tr>
<td align="center">O_WRONLY</td>
<td align="center">只写模式</td>
</tr>
<tr>
<td align="center">O_RDWR</td>
<td align="center">可读可写</td>
</tr>
<tr>
<td align="center">O_APPEND</td>
<td align="center">表示追加，如果原来文件里面有内容，则这次写入会写在文件的最末尾</td>
</tr>
<tr>
<td align="center">O_CREAT</td>
<td align="center">表示如果指定文件不存在，则创建这个文件</td>
</tr>
<tr>
<td align="center">O_EXCL</td>
<td align="center">表示如果要创建的文件已存在，则出错，同时返回 -1，并且修改 errno 的值</td>
</tr>
<tr>
<td align="center">O_TRUNC</td>
<td align="center">表示截断，如果文件存在，并且以只写、读写方式打开，则将其长度截断为0</td>
</tr>
</tbody></table>
</blockquote>
<p>如表所示，并没有数字，不理解。。。。。。</p>
<blockquote>
<p><strong>解答</strong>：这些flags参数是在一个枚举类型中的常量，如下代码所示：</p>
<p><code>code03</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    O_RDONLY,   <span class="comment">// 只读打开</span></span><br><span class="line">    O_WRONLY,   <span class="comment">// 只写打开</span></span><br><span class="line">    O_RDWR,     <span class="comment">// 读写打开</span></span><br><span class="line">    O_APPEND,   <span class="comment">// 追加方式打开</span></span><br><span class="line">    O_CREAT,    <span class="comment">// 若文件不存在，则创建该文件</span></span><br><span class="line">    O_EXCL,     <span class="comment">// 与O_CREAT一同使用，如果文件已经存在则出错</span></span><br><span class="line">    O_TRUNC,    <span class="comment">// 截断文件长度为0</span></span><br><span class="line">    O_NOCTTY,   <span class="comment">// 不要把设备用作控制终端</span></span><br><span class="line">    O_NONBLOCK, <span class="comment">// 非阻塞模式</span></span><br><span class="line">    O_SYNC      <span class="comment">// 同步方式打开</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码就是一个枚举类型（包括之后的指令集也是枚举类型），从第一个到最后一个按照自然数（0或许不是自然数？）顺序排列，比如<code>O_RDONLY</code>就是<code>0</code>，以此类推。。。</p>
</blockquote>
<p>③当我运行这个文件时，即执行下列命令</p>
<p><code>code04</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$$ gcc 01.c -o 01</span><br><span class="line">$$$ ./01 01.c</span><br></pre></td></tr></table></figure>

<p>逐个字符读取只读到了第11行的&#x2F;&#x2F;和其后的一个空格，程序就中止了，不知道为什么。。。。。。</p>
<p>开始觉得是因为后面是中文字符，于是在“读取”前面随便加了几个字母，发现读取成功，但是<strong>将后面的所有中文语句换成英文之后又行不通了</strong></p>
<p>又试了一下，一读到注释就不行了。</p>
<blockquote>
<p><strong>解答</strong>：其实就是字符问题，因为在<code>next</code>函数中，读的是字符的ASCII码值，而中文字符在ASCII中是没有位置的，因此读不下去了，所以文件中避免出现中文。</p>
<p>其原理是，读取函数根据数据类型（其实所有的都是这样的）决定本次读取往后读多少个字节单位，而char只有一个字节，但是中文字符占两个或者三个字节（根据编码不同而相异），因此不能继续读下去</p>
<p>如果将第28行中的<code>token &gt; 0</code>改成<code>token != EOF</code>就可以成功读完文件，但是对应的中文都是乱码，而且由于前面中文出现了“断章取义”的现象，后面的英文大概率也是乱的。</p>
<p>还有一个方法就是用wchar类型，也就是将第7行的<code>src</code>和<code>old_src</code>定义为<code>wchar*</code>类型，这样就可以正常读中文了。</p>
</blockquote>
<h4 id="5、TIPS"><a href="#5、TIPS" class="headerlink" title="5、TIPS"></a>5、TIPS</h4><p>①先看第64行，src里面是读取的文件内容，和第69行联系起来看，第69行在 i 的位置加了个0，即为封口。于是 i 的值就有点耐人寻味了。</p>
<blockquote>
<p>read 函数 返回值有三种情况。</p>
<p>1、读取出错，返回-1，即有如果 i 小于 0 ，那么直接print错误</p>
<p>2、读取时，未达到第三个参数设置的大小就读完了。这是最正常的情况。此时返回的 i 就是大于0且小于第三参数。且为已经读到的字节数。（个人理解为就是EOF的下标，后面才可以在 i 处封口）</p>
<p>3、读取时，文件大小超过第三参数大小，即没读完就读不下了，这时返回的仍然是已经读取到的字节数，但是比较特殊，其值等于第三参数。</p>
</blockquote>
<p>除了读取错误返回-1，其余两种情况都进行了封口操作，即便有一种情况是强制封口。</p>
<p>②从51行开始，到55行，其实做了两件事：第一、open文件；第二、判断错误，如果文件描述符fd小于0，那么打开文件错误。</p>
<blockquote>
<p>文件描述符返回值：成功则返回0，失败返回-1</p>
</blockquote>
<p>同理，先两个if代码块也是如此，先进行相关操作，再判断操作是否错误</p>
<p>任何错误都将直接返回-1</p>
<p>③next() 函数中 token 读取的其实是ASCII码值，并且通过地址将值带出。</p>
<p>④第46、47行，有个argc- -和argv++</p>
<blockquote>
<p>argc- - 意思是将参数减少。通过查资料可以知道，main函数自带的两个参数其实是本程序的输入参数个数（argc）和输入的参数构成的数组（argv）。值得注意的是，这两个参数都包含他们自己。所以argc初始值就是2，agrv[0]初始值是2，argv[1]初始值是argv（即首地址）</p>
</blockquote>
<p>运行时要解析命令，先把第一个用户输入参数去掉，argc- -，因为第一个往往是调用编译程序的参数，当调用到正确文件时，就不需要第一个参数了。</p>
<p>argv++是地址++，就是跳转到下一个命令参数，然后给程序读取，执行相应操作。</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>20230509（混账版）</title>
    <url>/2023/05/09/20230509/</url>
    <content><![CDATA[<h1 id="混账版"><a href="#混账版" class="headerlink" title="混账版"></a>混账版</h1><span id="more"></span>

<p>昨天没写，今天也混账</p>
<p>都是水！！</p>
<p>准备签证资料，烦得很</p>
<p>装好了Ubuntu20.04版本，如果有些button显示不全，就是分辨率的问题，如果输入法奇怪，去设置里面吧全屏和双拼换一下，换成微软的输入法，其它都还可以。Ubuntu比Windows好用。</p>
<p>操作系统，恶补</p>
<p>无</p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>龙书的散件</title>
    <url>/2023/05/07/20230507/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="龙书的皮屑"><a href="#龙书的皮屑" class="headerlink" title="龙书的皮屑"></a>龙书的皮屑</h1><span id="more"></span>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>挺有意思的。</p>
<h5 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h5><p>在C语言中，代码的作用域是通过一对花括号**{}<strong>来决定的，一个花括号包围起来的部分叫做一个</strong>块<strong>而且C语言支持块的嵌套，这种嵌套特性叫做</strong>块结构**。</p>
<p>例如下面的代码</p>
<p><code>code scope1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a  =<span class="number">3</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在任何编译器上执行，执行结果一定是如下图所示</p>
<img src="/2023/05/07/20230507/scope.jpg" alt="scope" style="zoom:150%;">

<p>第11行中的 a 是第10行的 a ，并且，观察第九行和第十位行，得知，a &#x3D; 3只在这个区域有效，而在此之前，观察第八行 int b &#x3D; 2，也只在第七行的 { 和第十八行的 } 之间有效。因此，最后一次的输出结果正是最初定义的数值。以此类推也就不难理解作用域了。</p>
<p>例如Java语言，定义了关键字来表示一个或者一些成员变量的作用域。其中<strong>private</strong>表示私有的，即只有该类能够访问该成员变量；<strong>protected</strong>表示被保护的，即该类及其子类可以访问；<strong>public</strong>表示公共的，即不论在程序的哪个部分都可以访问。</p>
<h5 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h5><p>如果说例如<code>code scope1</code>中的代码，编译器在编译阶段就可以确定某个变量的值，那么可以将这些变狼的作用域叫做静态作用域。那么相应的还有动态作用域。即程序在编译时刻并不知道这个变量到底什么时候有，或者在这个地方代表什么值。</p>
<p><code>code scope2</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a (x + 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x =<span class="number">1</span>;  </span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码块<code>code scope2</code>中，先宏定义了一个a，且值等于x+1，但是并不知道x在哪，x的值是多少。</p>
<p>在函数f1中，重新定义了x &#x3D; 1，因此，x &#x3D; 1作用域只在f1中有效，所以输出结果是____;在函数f2中，并没有重新定义x，因此x还是全局定义时的2，所以输出结果是____。</p>
<h4 id="函数传参机制"><a href="#函数传参机制" class="headerlink" title="函数传参机制"></a>函数传参机制</h4><p>函数传参大多数无非使用两种机制<strong>值调用</strong>和<strong>引用调用</strong>。涉及到<strong>形式参数（形参）</strong>和<strong>实在参数（实参）</strong></p>
<h5 id="值调用"><a href="#值调用" class="headerlink" title="值调用"></a>值调用</h5><p>在调用时，内部处理对实参进行拷贝，将拷贝的值放在函数中进行处理，但是在主函数中，依旧是原来的值。可以简单地理解为，对实参的<strong>盗版</strong>进行了一系列处理，但是对正版没做出任何处理，在实际使用中依旧是使用正版。</p>
<p>但是在C语言中，我们可以传一个变量的指针进函数，虽然也是对传进去的值进行拷贝后处理，但是传原来的指针和拷贝后的指针都指向同一个内存区域，即同一个值，如果对该值做出处理。那么原来的值也会相应改变。</p>
<p>还有一种方法，我们可以将值return出来，但是，其实也不改变之前按变量的值，只是return出来的值变了。</p>
<p><code>code3</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x ++;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x ++;</span><br><span class="line">    <span class="keyword">return</span> x;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f1</span>(x);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f2</span>(x)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">f3</span>(&amp;x);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h5><p>引用调用其实就是将需要调用的参数的地址传到相应函数进行处理。</p>
<p>但是，如果调用的实参时一个表达式，那么，编译器会先将表达式的值计算出来，然后存在自己的位置（另外的位置），改变形参会改变这个位置上的值，但是对调用者的数据没有影响。</p>
<p>友链：<a href="https://blog.csdn.net/m0_37618340/article/details/81070416#:~:text=%E6%8C%89">按值调用和按引用调用</a></p>
<h4 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h4><p>①声明和定义：声明式告诉我们事物的类型，而定义告诉我们它的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;<span class="comment">//声明</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<p>②别名：如果p和q指向同一位置，那么p和q实质上是一样的，则称p是q的别名，或者 q是p的别名。他们之间任一改变都会影响另一个的改变。</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>接上篇</title>
    <url>/2023/05/06/20230506/</url>
    <content><![CDATA[<h2 id="今天学的有点散乱"><a href="#今天学的有点散乱" class="headerlink" title="今天学的有点散乱"></a>今天学的有点散乱</h2><span id="more"></span>

<p>上一篇文章：<a href="/2023/05/05/20230505/" title="开始接触编译">开始接触编译</a></p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>即使用语法树和符号表，检查源程序是否和语言定义的语义一致，同时收集类型信息，将它们放在语法树或者符号表中，后面的中间代码生成中会用到。</p>
<p>同时，在语法树中，自动类型转换可以作为一个单独的节点表示，如下图</p>
<p><img src="/2023/05/06/20230506/cast.jpg" alt="cast"></p>
<p>inttofloat 表示把一个整型转换成一个浮点型。当上述（上篇文章）中的a，b，c都是浮点型时，30必须转换成浮点型才能和它们进行运算，因此发生了自动类型转换。且从低精度到高精度的转换是自然的。</p>
<h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><p>其实，上述文章中一直在讲的<strong>语法树</strong>已经是一种中间代码了。</p>
<p>中间代码需要满足两点：①<strong>易于生成</strong>     ②<strong>易于被翻译成目标机器的语言</strong></p>
<p>例如<strong>三地址代码</strong></p>
<p>上述表达式<strong>a &#x3D; b + c * 30</strong>可以表示为</p>
<p><code>code1.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = inttofloat(30)</span><br><span class="line">t2 = id3 * t1</span><br><span class="line">t3 = id2 + t2</span><br><span class="line">id1 = t3</span><br></pre></td></tr></table></figure>

<p>上述代码块就是三地址代码。</p>
<p>三地址代码有以下要求：①<strong>赋值指令右侧最多只能有一个运算符</strong>（为了保证运算顺序）；②<strong>编译器应该生成一个临时变量名存放三地址指令计算得到的值</strong>（例如t1,t2,t3）;③<strong>有些三地址代码的运算分量少于三个</strong>（例如上述代码块第1行和第4行）.</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>机器无关代码的优化，实质上就是改进中间代码，从而可以生成更好的目标代码（更好意味着执行更快或者功耗更小等等）</p>
<p>比如，上面的三地址代码第一行，可以在编译的时候直接用<strong>30.0</strong>替换<strong>30</strong>，从而避免进行转型运算，中间步骤也可以优化，具体如下</p>
<p><code>code1.2</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = id3 * 30.0</span><br><span class="line">id1 = id2 + t1</span><br></pre></td></tr></table></figure>

<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>即生成目标机器的语言。</p>
<p>中间代码作为代码生成器的输入，映射到目标语言。如果目标机器的目标语言是机器代码，那么就需要合理分配寄存器以存放变量的值。</p>
<p>例如，code1.2 可以被翻译成如下形式</p>
<p><code>code1.3</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDF R2,id3</span><br><span class="line">MULF R2,R2,#30.0</span><br><span class="line">LDF R1,id2</span><br><span class="line">ADDF R1,R2</span><br><span class="line">STF id1,R1</span><br></pre></td></tr></table></figure>

<p><strong>自行理解</strong></p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p><strong>符号表是一种数据结构</strong>，可以存储变量的各个属性，例如变量的存储分配，变量类型，变量的作用域等等。</p>
<h4 id="趟"><a href="#趟" class="headerlink" title="趟"></a>趟</h4><p>可以将多个步骤组合成一趟。例如前端步骤中的词法分析，语法分析，语义分析以及中间代码生成可以被组合成一趟，而代码优化可以作为一个可选择的趟。还可以有一个为特定目标机器生成代码的后端趟。</p>
<p>可以有不同的前端趟和某个固定的机器后端结合，实现一台机器可以编译多种语言</p>
<p>也可以固定的前端趟和不同的机器后端结合，实现同一语言不同机器编译</p>
<h4 id="编译器构造工具"><a href="#编译器构造工具" class="headerlink" title="编译器构造工具"></a>编译器构造工具</h4><p>顾名思义，就是做编译器的东西</p>
<p>1）语法分析器的生成器：根据某一规则，生成相应的语法分析器</p>
<p>2）扫描器的生成器：根据某一规则，生成相应的扫描器（扫描器也即词法分析器）</p>
<p>3）语法制导的翻译引擎：生成一组用于遍历语法树并生成中间代码的例程（没大懂，抄书的）</p>
<p>4）代码生成器的生成器：根据某些<strong>如何把中间语言翻译成目标机器语言</strong>的规则，生成代码</p>
<p>5）数据流分析引擎：收集数据流信息，即，程序的值如何从程序的一个部分流向另一个部分，可以简单的理解为，函数传参。</p>
<p>6）编译器构造工具集：构造编译器工具的集合      <strong>纯纯废话了</strong></p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>注册GPT</title>
    <url>/2023/05/06/%E6%B3%A8%E5%86%8CGPT/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6b7bf50bd41394e503f62969d764ed72c9713d4cefcb63092cc12651edcceb27">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186df8f2756c43971a118e851709297bccf155b395cf773d208ccb8a172a2b7fdb59343265437c52df6e148cfb73903a85bd7775e486d959713845b7c0d63c0c2daa8fb39a105bea6d9085ea460c8f9e730fb6331b31088000e2538cabf7de26b07fce0a9b71381b480b63b934406caa07ffa2ab87798be35f5fbdbfa8907a37509422eb7724fc428acb5a0b8770bd3968ff160a13472fb09413da2cc4af69aeafdd7db9c8d4c6e7242aa01610a7ad737b86629be436cb906f1ff3bc49db88ffc4efaf3c50f147484826af90623732b10cea9e6fb89552ab84306df23712a88057cac6409fe2de37cd8568cc00573d7d1a15e5560d500aa0007b54cce85c64697aef818d4dc97ade896b89973f473430f46daa7a27749373c43a175a1f7e398d55dabaa30d4d4372fb2627c73052a4568f071038f010283bd9749c96b03cf3cb4a5bb88facf1dd6343a8b8250e995d4758d97ddbc79b858ee9d1980c205937a1ae4328ad1f65cf96b6c071283685057fd23301687882d3a8d941df173eb5e6ca1dc1cfca66f8b0e808799f3ff2525bfa2c3f322d51dfa3331056403a804186eafa4893a52175da8ea68abb48bbf727b08e18b4eb6b3ebf86d23eed107e9d0daaf926badb1db3345071d9b88c8bfc536731e990be76dc058a392b75aa7d67c6fbe46be802aa8b156102cfe8be18f762f3630bc3552e194bd4958a84c05ae4711e6bc07fb34c9eaf2012daeb74c85aed326ba7d7c3cefb52498e6f76dcf2048ded3df12caf6ade1677a8cd745f776bb6e5e9e579665c6c2ef09bd9b00a8b27069695014531bd325a3370ee0c64088a044daa0eb9d711c25fd5a44de3bd56ec6beb2fe5862173bc2c720bea8fda58482670cf265856c6081ec0200032ff26a99a16c6004ce3631aaf3a5847c283e615eb32aef4ea27c18633a7550877630dd522a42542ea549e27ceb85bbc2e10f3618acefdb70f29aa551b6bcef47d7896c1ac7d09f052acdae3681f4b491fe8f31290eacfa0dd99d433ffa14368930447add6f815264ff9d8d862d44d05e0e373d5914ba77065c3bcdb876434588b3d9e42b25a6aa49fc2c2140d4e5011bbb873b4bc84e0c4c41d78d983fd616189ef79c750e50fab0d9e3ad3c980dc438d6b6af9e71a51449fb990a20f92c3c8917e1c5e231c39f9290a6257780ead3fad84917dabe7aa2feff35c63762ad0cd60dc414b335f052074644068aaf8d16790507398887935d3c60e602ae47a4f4cdd0892759961921bb54976b88a748b8d158b65be978ddc024228353959873f8d3f69736533fc6576c8346c5d5ac44fb6f03336238a5729a2024fab8dcda6905c8af9afcfca0d1cf58726799ca00fa09ac9b94d4ed18190c9553df151723e70d2444ba57435c068bf1637d3cda0ae286b1c8e16fe3755158c41e0826e4f373c3a85c9cff0773c0a01adad108bf0a29ef99471fbcdcc17813269577dd1e0b654fe854ce27c6646d5bac3bcdfce139d08e024f64f90efc66a10c9e65540e5b6d109d4770d90232b5729017a9684d631a06bc871aa51e34fa5ba2bec1b342e59fb918b795d70c2f1989c1afdb919ca7b613295b9bc47b86bb0eb7a1c43bd6b4ad1a5cc61a8aa1639940d825ebcbfbabd2e1ca6910151f3768eb48b63462d503cf96236336d9aa536b71649bee6fbe5cdddb6c51bca4c38c4ced0b96648965eff8cd3de0c5a94d744f9962391e720a8799266550bfddae4d728c1cded2a26afa638bcb745a00f51a3bf2683d1d9fab2a2952160ae522daab913806f039fa38a007d811976d450f7246a9548e80706687c6fc2e96f544f750e306ff0389f67503f53e473224577fb77cd031d6c19fff445700f9d9d36cf6b2ad8639c915813756ea6e608aefbc1f4714dd0689c696d371cc87522b516403b171903397da899bdf92a7698fddb87041034f5924e8e065637b33824da259a6dc9c40aebab76888335d7c42cba7be4dd025263b2824af32ab43a8097ed812ff315a613ffd0d476120ccbd9848e30c21f8ec21ef251bbc47cb2a31de5d1db618966c633b2671fb40171ac864fc0ee993d102d8668c15726e0aee53c26dde7906d49977658001351d0d3569e8005ae95848e9a2ca22667f3bebdf87c3e30e8df383c90151ec4e5124d3d0ade11b8a278ce9e3b83e5d656a8ec9cd74518a8f939a96add385efd16ae321e7d684bfce848f62beded900e1896188be171a6eaa8dd9c1dd340bfd08e3cb1ccdd51ff4497026086521ea4f839354b15dce436a3d48dea2fa173678f2fd71eb09ad32b26fea94c7d2a6ba2c3844c9abad931c77fbe3e46cc8220a2c84502212130a6e849ab4310f74a8e031f3718909af7999009ea3a8089698389d535685a24af3c9f3aac0ee142ff3dfb64abf937e78f3479fcb00644399415bdf038f221a8974b77e872193ff6679b330c1a1d35fc21efb2684de135bacdb3a33b5629f6ebee92ae67510872ecdfdaf40061d89edd93f8e3bf2d3c83121413649932f1b2bed5049930ae0a1909b469a63c249f1be15f0375d8acc98885dc8de96dc56204401b4fc0b3334e6aa2f2a89d42a775f88e72cf618b5c2d6bfe42a767fcff2e626b8bef18e685ee8b401f30ecd70a6629e94f3351af564169f6f13508c5c226e98e1dc424edef9d55d6f427be1e6abbc31fe63f24f74ad065e2cb8984c2ba985c9f9ed30cb900d74472f5335d13ddf27a7ea28088ba77e522a9d59c4ab00ec9f52c80f3e1733ca37b37f7f5fca3150f8d98ac584cc22f44de606a3b103b6fb4f106d51447a5575c4b2b222828a73d1c4c3c76f3ab18ca7377dbd2b678eef260616710588cfda8058dbf1b7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>chatgpt</category>
      </categories>
      <tags>
        <tag>注册ChatGpt</tag>
      </tags>
  </entry>
  <entry>
    <title>开始接触编译</title>
    <url>/2023/05/05/20230505/</url>
    <content><![CDATA[<h1 id="编译学习"><a href="#编译学习" class="headerlink" title="编译学习"></a>编译学习</h1><span id="more"></span>

<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>编译器是将源程序通过一定的步骤转成目标程序。目标程序可以接收用户的输入，通过内部代码的加工，计算得出结果后输出。</p>
<p>解释器是逐句执行源程序。编译器是整个文件一块编译，因此，编译器比解释器快，但是出错率高；解释器的错误诊断效果好于编译器，但是速度比编译器慢。</p>
<blockquote>
<p>在把用户输入映射成为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而，解释器的错误诊断效果通常比编译器好，因为它逐个语句地执行源程序。——《编译原理》（第二版）</p>
</blockquote>
<h4 id="Java语言的处理"><a href="#Java语言的处理" class="headerlink" title="Java语言的处理"></a>Java语言的处理</h4><p>Java语言在机器内部处理时，是将编译和解释过程结合起来执行的。Java的运行环境是JDK虚拟机。Java源程序通过编译形成<strong>字节码</strong>，字节码再通过虚拟机进行解释和执行。</p>
<p>形成字节码，Java源程序就可以在不同机器上执行，因为字节码可以通过网络在机器之间传播。</p>
<h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>一个源程序可能会被分成多个模块进行存储，放在独立的文件中。有时，<strong>预处理器</strong>独立把源程序合并在一起；同时，预处理器还负责将宏转换为源语言的语句.</p>
<p>经过预处理后的源程序作为输入传递给编译器。编译器可能会把这些编译之后输出一个汇编语言的程序：<strong>因为汇编语言比较容易输出和调试</strong>，然后，汇编语言由<strong>汇编器</strong>处理，并生成<strong>可重定向</strong>的机器代码。</p>
<p>大型程序经常被分成多个部分进行编译，因此，可重定向的机器代码有必要和其他可重定向的目标文件以及库文件连接到一起，形成真正的在机器上运行的代码。而<strong>链接器</strong>能够解决外部内存地址问题。最后，<strong>加载器</strong>把所有可执行目标文件放到内存中执行。</p>
<h4 id="编译器：将源程序映射成语义上等价的目标程序"><a href="#编译器：将源程序映射成语义上等价的目标程序" class="headerlink" title="编译器：将源程序映射成语义上等价的目标程序"></a>编译器：将源程序映射成语义上等价的目标程序</h4><p>这个映射过程可以分为<strong>分析部分</strong>和<strong>综合部分</strong></p>
<p>分析部分：将报错信息（报错信息在符号表中）和代码的中间形式一起发送给综合部分。</p>
<p>综合部分：之后再谈。</p>
<h4 id="一个编译器的各个步骤"><a href="#一个编译器的各个步骤" class="headerlink" title="一个编译器的各个步骤"></a>一个编译器的各个步骤</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符流-&gt;(词法分析器)-&gt;符号流-&gt;(语法分析)-&gt;语法树-&gt;(语义分析)-&gt;语法树-&gt;(中间代码生成器)-&gt;中间表示形式-&gt;(机器无关代码优化器)-&gt;中间表示形式-&gt;(代码生成器)-&gt;目标机器语言-&gt;(机器相关代码优化器)-&gt;目标机器语言</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以上括号内的内容是编译器各个功能块，无括号内容是输入输出流。</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>1、读入字符流，组织成有意义的<strong>词素</strong></p>
<p>2、对于每个词素，输出<strong>词法单元（token）</strong>&lt;token-name.attribute-value&gt;</p>
<p>​	例如：a &#x3D;  b + c * 30  可以被词法分析成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;id,<span class="number">1</span>&gt;&lt;=&gt;&lt;id,<span class="number">2</span>&gt;&lt;+&gt;&lt;id,<span class="number">3</span>&gt;&lt;*&gt;&lt;<span class="number">30</span>&gt;</span><br></pre></td></tr></table></figure>

<p>原表达式中的空格会被忽略，变量a,b,c，运算符&#x3D;，+，*以及数字30都是词素。</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析用词法分析生成的各个词法单元的第一个分量来创建树形的中间表示，常用的表示方法是语法树，树中的每一个父节点是运算符，它的左右子节点就是进行该运算的运算分量。</p>
<p>上述例子的树形语法表示如下图：</p>
<p><img src="/2023/05/05/20230505/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.jpg" alt="语法分析"></p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析</title>
    <url>/2023/05/04/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="08c1c8a2e59dfda697e9f1dff9eb7128877d75e23657bc6d9d8986b206fb8d0f">4630436162ade97ba2718b7d0c4b3b63501b8b0e90dd70c68cacef77fafaa69cb655445445de2a757b2056ec9ce280fb4f205d7f6eb5d4506eb630ca932e06992a79c661e63aa74787bd4cd18ba35f0fb06d679e484e67672b2b103c73a777903a3af263a3ea0cc1e572fbc2e7f27e0b8fe1e34d8e411e783507e537d4ff1967e0fb33a9bc04f1c019dd2296e004deda8fe01437fb6f53154dc6be9dce6f7fbd55bf8720a68d61c293ebf56882f9dea122b5535b446a87ffa1ff747a31a23c8efba759e2dd08b062fa436f47e953de76c2b87c917add3ffb0739bfa6381f8f21951db7f65e98ffb5bec571f4f0462dc6e1116ffe2a5de9f25ed44d6264a4ebcc316d70911975a1e4bd1d421d97e85a9f397ef0c95cce1dfd2a41f6cf5090447d63703b79e312ae290064e31582546ce60f8e75be17c0f01facc59db5520da845dddae9720e8b64a4eaad8cdb7e7d9273b87d31264cba75ca18f3ebe170f745f7abb1ec22b151ea0dfcf9b8de1376f9c2f1071c3aa4757c8291b243d2bb5f4489f0de87a90b245ccdfebe57d4e057c980812b26f9c318f5c91972ea3ba74d233e34ecb7e4dea5e7602ef6e40dd3d7ced7bee47f7595371d53b5444aec0daa8d4bbc312471ea55e45ebbe84dc42c4f584ae7c66ecbd097f93df7ef18fc08778233d77f3cde74aa7a604955869a97d0e626b0bee922b88ba947d05bfa592162a58851339ad8929d121385426b7d46eb0f2ad2c46b97ecbf919c7dc0e7a3eeeaf70285e87f53b25268e08d4417de2001699e5bea937f706e05cb32da617c10b40de9c12557e7c9b9c324c65dd5d5aa4c29996049b0371685fe53e1771e6100577f85a170728c8204d434b865d75de13b5990675ac06990f5f6507ef3b7b4c082dd16378daee1af80e6e89c7cb2fdba6cf4dcfe694f8e28c560b330ce6d98057b3978a1fc9d8e505bd11038931d9616c5b3f6506a57da2d9fb562624e87e34ab62b24d8beaf0bae6be43d1087de867e56e269adadc712a72f9c90eaee34e7ca7be182305ce3741f72ac1dab6bb6bab70a8aa376d43251410e03390efaefdd893bd5b96a02dacea8a3e30a70a562213ca022a0caade139a8b6f9495b45d56ac7f9cdaae17446ec8a0c880e34372d140f85bdbf25914e4d4ee6d71df326fe0771b67564e83c64130c5cee5a866505c17596dac7807feb18c2ae46e7ae1b37f2f1b112bbf832c4391bd928f84176aa67bad129c51465e93f6ddb53774868e6481292033b200a39f58473afc8660848ab9a2be928c142c895dac17280af94682fc61b8a4be6155c2bea972c05f6af2cd08efe4782112139ed7c5e26cf1f559f95b1345cf8713f1f4ac33a19a10f5810778d6ba57296c28e4e31e9e44bf49f54055fec8d74b62256fdbe8552907dfceae32a38509ea90ed81bafeb9ae239c4b7ef593e00c49603602d36c08b24a6554f5540db8a1621ee6019dae4c869825fe2fbed7bca3bd7238e29434579b40350ee692dbc92b744e5e6eeeeed5e775617fbd648ba4d19de6b96b0e317d82fabbf50fadb2438e8158cb50aa5dc7f671e1d4cbc98c9506b31b62b8d02dd0219f5d9f67a9cc1694772d6bfbc47107ea6eef0503a84c848f5d4c3e75db8ed8fce0aa425714aafbfc09c28c15693894a22ccdca9b7e3253d4335d7fe719160cbaf684a57b4425ec6c36f8b1bdd433b12ab4b10afa7bb01f14419db77116af042b44387bd95d90303e998c2ee5b993438bf863d135be1a5e3b17e2374c24871b69b449d79682519f795da3a4bf1eefeaaa7e895a5289b8b1aa50fd9a68956e1130849db254a79f9e2d974fd5abe33408596282304d853aa114f9859383c265dfb17cdc16bc9ea2cad4c414a153062d7a201f54b1f04ad0505d2caf172ba205af092b43ee78aa99cc9f3ac0e1c1b46b1a1652b7e3341340d9ae42db6d6ce15215cf6f2d4b8828e6f533aec6e1d04c21c21cbf4b4f6182de9f44eaea285efbc8fff779934d6634ea476cdbf139035665380830b2e1c895c7ba27a596f1e03eab2e71ab18e1ae16a7da87226429465f5ee9166e1e8095e9bdae30b83d4b040c014864cfaf80f83acd24a2ea1cfdb3812343edb94d3f9d4fe8c142cbee58c49bfb48de6ae1c2875078dfe929506f6081670aaa0d2b5d147c9b91c2859e07b1be8349e7f321ba351184262f975ca2b5dd2be5f0f7bdc9c8ad787b84f9d6a80edb0c1c1be1513fcb0bb04202f0d11259b46e1781ae35dfbe8e30329ec77935d69a986adc66db802abe2a01be3f1c861510f5f60d04c7fb8b7f0cabd43fb41a76d54537410e657b49e8bf713b67741ef327bacc82b6640c856655fca260b1b5ab51e86c8450ded710e2163b5fda05c7bb9a8e4b504eaa7b887bf0e1f412dc8bd3a12c577dcdce1bf6239f08b8489139c7c9c6b3f3080a7a3a92b4096771a9f4f523edf8ff090c51a4c82c1191ff913ab1adc7a273de26d67b010edf5d3b5dcd04e779bc85fcf7268df1669667061f0e40c44ef6738b9089adcd7e0764caf9a9dd3147b22fd2915ae0792c953a2d03bdcc9081773f29f7713b1e9541ee0821a877edc8568e2d394c3b354b1170a01020c9908496e1265e4636eb3af1719e3d5aa91548784b6afe38d237c487ea8d443d0a7f5a0d8c9f7c69ce9a2a546afd00a317fbf2d2b6cd17c4e0e7b45764f5a650e25e7cb4ecaa190c27c5178f5793b8b5c8e952beeb596be401cd28d0537f4476414e50b5c2c08914eeb39aa5eced11399beb1ec0c387abb88b0dec54bc6be88b88f8e76d411cdd2156cf2702175c5ec9a250a500f64b069dcfb5fd048279e276ba4dcf3f3d367fd1e412bcc5301f7638b2a969363689ef54db33b5d8fe27028534122b8f359941d30793f8b76c3d8d5f2277f8e7079e2709dd82e7e74e6a6459016fe1b77bf48f18f35beeadef4b96b27c215690b14133906145eb6f40a40ddcd8a80c121476cc03408f86b601be0598d8128ece70b48122ee1ada203e23697e45e68d72220783e7179adc2835f61dbb14c9b58153074f6cba9f7bf96799d3ee8f13201fda3f4dcac711b48e616520aa6cb3fbd85058babb04b6919b844c508ab0d71437d9915aed7b5f736bc8418439f4bf5ad29eceb9067ded1529a4ae783a8bc65793dc79cde806c45bfccf4ed880ce338b4d601728ca2885bffc4c7dd7bac8e0721cdebe57cb7b5e5926143394588dd7f3657a41be624205e99454f4d2f244d1e27042a5d0abdf8e6ef9e7d2ae1a3d02196c8dac83b755c2a3aec05060ae6a08be481d183f707af4a40bd78ec031bdaf7b5e0773ae87b7933afe21ef672bce9d2a8de5c8ed28819f6dbc11ef80437ef38503c60259d7f2feb92d7dd836b3e1648b93e6e7b7554c4f6c5ef8e39abcf6c79b2a4c49d2d1325be1e87dffae8a843f0d41915201975d01dca6b306060c05e0a006fc7dfd85bb5e7b10444e23deb2c9656ff3a5e63bb6a737d3ec0e6cb3fe63cd8bb6b71ccfb4c2961ffc720dcaf27524824f6a826eb6b5bf827f6381b8c26288b00ccda8f70c97d632605d4e975dee46927f4f588e722a29fca24970bb06093b4977c575927a93a853d9d6b21967615481f47f741936a0331dc947cf13d3031e3a32087b21fd09de46507c386f0daa7b8dd663b1f65d7775fc9b38d3e37fc52ce5c1ed2d3f3dd084847f1cc0df8b49e5baaf269fed1001fe2a6a065efb4ab66e6a835b8bfc441528e20b5d7b3bc9d517b208da32a41e24a84c55911a7be43097b511fdf1221f8e8f587c63be93c4a24298d5a482f3de45454f8671e3e5a69f9e8d25e6bf0cedb1fe3b98496c2a19bd975fe2fa0dab7658667d9afad85e3dc798e0186cd1e4bd90469218e7f0480dcabb890124a5525a1dd8452c5988fc15ed144b5fa97308880242077e7fed1bd570615014a7b400fd5af545f1d696eca394f5e9861bd4e9b8dd807981d83f95b5e779eac39c4481e251f441eb1f2b943c9af5285f81f09fce090d29b2be5783a06eeb87a62a9154e78cc10f4ca3a953457a1ba999eaf80d20c331b54c505ada843ed749309714443b5e4b0a6c4a2208886090fed04e572569daf9c4144e236a8b24f6552fe6d808e8478045d33be3ea8a7b37fec2f2f1e75132419caf2510e8272fbe086752ffc41b6869dc72fb92f79281a591efc14b2926b915330950fbc6ad361f23dd3fc3147c58c8b5df08d5bfd51a0655d4b52ee516056ec1bd416b3fe05ef8ffc08e5f431bf5d4766714a906ffba1b3a778c2a075721cdb579a0553331e8d1963ada43b6c3dea1bd2f614cc87fd33a60eee1cc2e4729f27eb6017e0d68ad73792e8379bf36a50fcbe259cf76faf357ef8e6d1be669c3e814c1fe19644b5c038fec2c8f6837d1aacf80c0416bf018012523cd66a6f06d700ba4f8a603c11396b9b4b72804cf76959715e27c3a361f7d906f221f8f77bc9d124011dd7d781a3b2b90a0453e289e43fe7a8ddec9b499aabb865e607cb3179ada10075fda4b393c7d15092b566e4eeafd85d1cf54b3b05c48def525da82871a48995007b4e8d3f34858e9d5b7bd781ff7aea1544c2bbca005340a00aa3f723a851868dcf8f7f62168b9f2ab6af5694c4b108dd979a238d55617f351ad9d39ed17617e4329e8778be29decc4e02d0be4cdfb6f946af9536c7ffb16cb8354f06887ea67b3eca34c37992475fe42c41fd2f3867d21dd7a3ac96a1a7622305c76321068f1d790d1a78a2cf27687616cf49dab6b136a9d70f07a949b65b1210b664097c0df714d70732d3c1e0c07a56fa7bb218f484bd741a31f95750345bf05515b405c8dba20a657f2778efa0bc34f726ca5cc0a13bdbbe270f3147c52d8091890d69e2773b0c1618aca3bfa36ec05d4050e218c60dfed3d82b0ecdfb35ac06a7acf57ae0466d12bd90226af82947addbc3d7b1e5749be72f2b3c6f92a2df670efec7fe785a1b7a3112d074887e1e2e0c90e55f0df82c242a6a31edf44a94f2a3fe3668d54cfc254ce90693918210911b18e3cf1cfe965079a750d12d267eb39f94dec96e5035180f6d4c171f38afb37ceb0a850418f6f6decde29bcb61d9c93658dc9b05bcfee4a9323bec51d26a4397dff233f573719ef1c9ac815e0a6fdd13a3a0e30fc7597fabe0c26847fb7d0ea2dd207472f47a04950de56178f5015412579336bad7be32b07707084a7068d7c10532db959612c9795fda9a55d10ca83f21aafa23c01d7436032537b0ec3f19df632b47c7021f25040d8b5bbbf5ca3b4dc022af37c029ddebd5b811de9876a7f3b991628b9effe0a69484e4c68b5b754e70e0e286b35adf4cf4bf32678074920a150441c2158f53c46843b57fafa974c5a6de1b3a7ce926739ea187a2d50ac279c067cfc68194d10f8b0ea733f6f4e568d0bc3cf4b5e776cabd9e1ce56d11c9565c05bc7214c394e00ae5f2f4c553f9e8be1df815b3797f8ec48d2c9aa63854470c34c518c8b6e77d03172bce6a5eee1e1a65961797507f3f07d577f90fb66184b1c2f5ed9a724a345b1903632fff8a693269b6bc8c0ad1662f10151891441bfa197df158427cc8631a18ec743f3905172ba840befdac6c392282127a3210628176acb9cb0d7c7de4b52e4aa6e8beb771ca2cea4538b1363da976983efc31966606dbde54009d3614cbb09d1b1908425f6a49c124e09849310b6418e6f8091269de37580303d5a5949f0bbf75fb60858bd90d1b8ae48536b0e66e14e8d98e077b71e14fccfb56f69ca17323b74ded6560751e3a8a5e1cc8652cf4d015ebd14c320bbb36c8ee4da5608463989f144b7e004c9e90ff75953e4c69b95155d10d1898bef2593b16948d398916110b9ffcff8f2f3d4606e64c15fcd9bc32caca65901634a0f1632459234997255cdc6c24b1e2cc915c9c6518565a6d3c1b1f9e1a05bdbbdf4a1eb97c31af806dcb663a240d018f8e83f3097fa81bafbd08267c8aa70b6d48e7f835dd2b1eb6d3ef83986b2eab86fb86748b2eb7cd4c1535e16eb13d394223dde630c9be81367c6c6bedd6a110034e08e614c324efc04a65cf5a1a92abbc4f2cc4ddcde1566d3b387a8a25004eed7d2b45cd40e17502a007aa6307fed54334d054948aea8b7f2522222c37374b4ab9d2fc5a55ec40ca4b5a3b0d72b0d8d9d8e46452a537890fda36c7701ec8e56a5d9b5763de904480c589b81161af6e238ed645892fbca0111445e8f6592ab425c5caaff6a049da28bbb2078f615f73695cb80002a31377db8af4c72f34058d2e85e611be92be73a399d46361ddc2e7dc3dfc76545da40860bfe5784096831c4d16844192b951b08536954d8db07e747dac6488184a57bcfa5b4b4681d0d01eff0412903c85418cb6632fb382d035f62160843aa8cf7a0fa3db77af46f14ef1fe624ec48d038bbd8355716b0c9656f465ab3c9a7d4dd97cfb244d29d5563ad43d08820550efdc0cc6f168ed5dd2719ffd8cc777f40a48bfc5224147efd1fe07b61a2c227279fb8a0e0f07c6a82063d7a0ed8e4a41525b228ff464bec19724d16ad79283fa2277e3bcd69a42c60777816cd35e567b08dd614f0cbebd639483d7339a4adfa205de8598f54245e27689c0c990dcd68ce6dadef52bd99bc3de4f3c65952110fbc01252c13bd247aa1a6beceab0585bc8009993ce0921e1752365e7dbfcdf6568f4da949415cc70da6eccef4a525065934c9da57c62961ab509d4a01caaed75b120717630328c07b708b42e137e82e9d2589066809f0090e3e8afc770d5dd8dc8f2e038927863af6bbe1d2cadcd01317b306f13d8d681846a139feb566567433fb44181b7fcabcb994cdb6934511b3e359898bd06725af25d877f7391fd0906934d15b33fc6390b50877e1dfcf95e71aa09a636cd1237b0d6acf3cf77e7b75d6c49f291d9b8a1ec2ff0b38226870e25fd4cc8af6c3dbf5c53dc3e253adf948095e0b3b64bc628e491ffda2fe4ac80fe1ade53fc624ff584068e4e7ac694be6a7761f58e4736c1415c1abac2b543efa906be07504d38b2b7635ac41236fdac1a5276ef7f399c730468a414a77873be2b527c59ff7a661e08cf8f58fd5b0924849440c148641bb3ed14a6991037813fc93e83506b5e6a12605cf8e37e3606610af321205e561050925fd70525db0531eb02f6e9ba66c6402f3c30cdab803225f1d2f0bb8fef6ff5b297e5e97a693ac83b7f37102ecb3853762e00ed9fa2aaae3024ba2915df1cd6e6cd942cd038ccaae5827ad520898d6084cd6a5c5164101bb41651a1f7c04be16aafa4091860278fa92fc24d8eade9fa1addfe5c817f19b1b77358fa0d7c89369186942eafe2f83a650dd552cb5c27b8037f55b504dc8be630bdbbe646a00cb6c740ee976315a7ab915df53c3d45bcd112e8a4f518fe52f8a74fad27fb8a45df0b78afd86fdfe19a73cf7a82255d94be3ee1f4363791cbff64aee31c1dbbb4c49e5623a6671400cd54ddfff00c270d479f8ba5bb335346763d8a4b1d4efbad23383af460014d29115d4b80d1a89261fb2f1965a4d6f2f8aa0f4609f2e8e175bd549c31f0a1bceca982366baea572922b814a11cdb3ac10065183c6688086aee25dcb3b75b99d4ea731a4abbbca8c2981de3fccde5276d60e942f4fb15b0ad4d71912201767d6cb9039bd3a3f734a8cc9167157271d9b1570ea8d6f4fe07597b23e30cfd79959053ef41108149db6ca5cbc81bb945c86f5652eb2e993b24436183fb26ac5b6f7f7d1d23836a2a598a0e880ddaf3da80b8936adce0e9785c4a33da3fea4dc3a28ae79083defa38c012450325083725d4c2bfff2d086719443c900f195238a4f2a136eec9c480e6fb486a9d4b3bf3a387330660acf4826e58f18534aa7847f0ba654245c731ac5946e1a80f4f8b983ffb119b9f1ebe81a769ef12db084d2ad4d03dfe99881c7f5ec130ca91132aeb039378f6f0978a67595e1672277593e9c465acea25977f8a697be0724d63d2dc4d23cf2867032e27af3ecb841dc69088c520df1c8ba58229b5aa6f35fcd2adf0f4767ec536457dfd222b1699c27e67f148f2c6883a788c9fc3714f852fbd238b1fa1b07c2b64b555f17ef3886a017e850686e89fbc5e12b149686460ba7339293080ed461e4d21edae25be1c5bc5bc840eeb4f3ed6d3145e08202e91fd50de7e5ce7486ed8ae223426fc6549b5cfe5cdc0cca3a0b9349fd88b50a4242ca74d30cfac4f284445f90a200a84ca57852920f2aa18f1127786330e11302dbf7c9696d43418a471a0de00a4b930a62bfdede4ba0cb134e68d15829c9cf0dbc1b75f01c396b5863ccdfa2636733f3108ac1305b45e1275cba4c53e4990a767571a6836197d25f525eb207ff36f318c7aca597baf0e4edc26ec1041308848ccafb45ca7ebfba0e4da8ad4e1040f601d4247fe1ffbe1cda0a7ceabd058cfa8ae3171bf4b1335b609d62ba89dfc4b7a8f0f2035560f42d07e2651693216200fb126ab962cca164880d023d0e7cf159f8407308c4fc5dc80d50369d72308c562a984f11d9200516581b7feee03400d7482ad7df32991177ac192d516e544acc14dec36267ff35f1cedaaabf335af71740643f1b6f83a298b43c0a32cb27ee868bf3ec824d82669597bd3171e7b8a729dfc2a608e199cec0a66fb35e371820f58c66e0dc6e1c4d247b5a7b970f1255349bcc0595f03b030ce570259ce64834b56b293fc38de861790e8ade489df97b51b1de52db912977215634f66dc3f04845535fdea27247008bc25fdfab3f2d6e5dcfb5cc30030668044f9414c020c4bd9eea2166feb6dc9199f86c876602ea5f12252d5ddce61181e19f67a03d5abae014319311733637cfccdb1e8d0fcbedc2e58b5f72133098acba1fba54a9106939fb5430f2075b3ac8f9e7072705b399fad6d0613ff678e7ca87419cd8f5ee0383d57f17494f710a423a4653fd3b72265c691e4ab767368f7b7b42d05b030f1143db99e08d8fad45d006b1eb222fdd585b63ff9f9f0c16cb716cff9f6b5580435a1488024eefe7604ea9a1cdbb94eb2e8472bffcc47c8929287d6ab2125798b3f1d3f095bfb5bb854ab10b06e8a41611efc8e75ea07b2a151685a788f7d45baff4651ec4ef44107c122c19d07ef6e20cfc3837768f2fafe02b47f09a5fc1ba65284147f1292029c159a96c5749f4c209897552c191f4f129c4451bec81068786bb1c93b821f4abac76570372b70104d47d5f89d64f98fca5af177b5f0202519e322db9fd6158cf95de44c7be900f11e215006aa6f55feee337bb8b55e1821afbd3797782438a69259f70f6e4524530ebc1477ec6bbbbc3790bd54ddc6ab624077db237d062fc4eebacf62d61b63dd1f193f59f4ce2adcee4af8656bf9b82548f6ba8ceb3d8fdd581119f50b379c9181b6ba2472ac027b575aa3c798f91206c8a44b5c6356241a82dc3a35e59843635ed58b17808d88e7b242281bfa395a7c5b4cbdcbf9be1a71eecd5c780586a342ab128e2d735b8bd4d4e62613cda5b600655a41fd53f5d66c2c5c3ce9a7198d9bf5020deb53943bf882407b52086be58b05c60659c06d99e741af228893b6b694da3427b42c40967a24e73e6b7cc5a6f1299bf0a476a9351625a99b6b10ed23fe8b6f7a6b96c9395f225a6fe6f07e1b4b01dad90256d76a66c4741ff463b39a23e24fbcd81ba26219ff0800471871d19f1009b1e4c7bd99613b9b832b841ce949803cba16154571cb77f268b4ad35847c48f547839a288820f07ade2b239e66614c402f6e6d385bdcaf404b293d2ce0f04f0a6836e5881f42de60f9ebfab386cc171a857aa28f5913980c25cc16b2695f77e64be0ed6edc2ea6cb35dcf59ea0e51ae593cebdf4bd5a79922d33c73f8cd28527ec50a72551ae90ce75ddef66fe2ea1aff193dd00a79552985109e91b65be326383a092d94b9a0d3e1e5b8a39a789e04cb02ad5ea2a0f6036aa47b1ac1d380c2f5cc1e8e2dd0ceb982e72121a07b6d1908622107115a5f31e769f1a94175a679f4c4d792ad7e56c2a6a6b0c6645f1f5ea2863f6e108e4787fe6ceb92b8e354769c17f5393a3dcfbd888b3dce4acac784061a4b5664f725c01054197905799fd02703421efc2b7f390a8b4c1407babb88e813b5e5ab1296a5fab3d5dcfcfb4a96b75497237f07b1f34d7d9fcdbb576cca9d70a25d24feec47d0db7494a2bcb2237285271d85625fc4c5e6f6775e616917031201aac5b1ba615225663c5b8c54e7a0645c67f271eab4525ec3671939ca9900b99ab89244bca83d34fb5a0e9fd92e8804601623e408671d6b36ddf74c221f2a6ab27ed6beb67301f9ecf8a5ac7ce87bc5344590b3af1742ccf3044a4b6da088869809086332f1ad6cb303f05304747c6b87e15355050d135860e1a585f05d193f9c340075d77cca9c43b7b882c08382e319e1d81ab2b6679a07c544efe427fff0b511d15f13df236462a7d5700ac292e9c9c21b5317b65953b63ac8be4b41f8c68e2d1a92f677af83399bbe19def1fce44e32dc4a4b58caa7bb8345b19737fa68ac9f351362309d796245290d439bfe8402c1e114d8a0d11ae529d0e69c61485bfa406c97e3d8cc1498e1302bd0b4ad455b2524e29e991f086c9ad5b6fa091f6ac1c5723029f4b017a6d0d730ba6fb1b706ca4192e6769a6484aaac9c16e8db6320e5ad4227cc607d20ab0cad8289617681a1673f48ff273f8c96436c21244aad5d8c9b05b3571a33eae6ea0af68b7747cf2e5ff052e91beb5d150c3ae13bffc64345c5e5ae1e66dd1d40a23f8d6a85768bb46edf7fb20becf556cee3649c3099ffbf0083fb97a4c49ba9e9b879722d8e91bf58bb7fa2ef0d670087f37d2882543fcf46297af0d6ffe5f05389428d02356e1b23dd80a3137b29c433127e6925e2389bbbe86a29f1fbd30a64f85cf015854d965104b7b4b588e0b96f02bc0e47d39c172863954deb01b6077f3998d363e68329c811a15e01d5266950b0da097f3936b050f0f85a747d236f823ce91db2e234cd8096d9766bba6c9ac668137f6a9df576ad61cb3fdb96b6a1bd80ede10598d5ee4837739d95ef1b9b316ce37914d7322932312aa39b223b501ee29ff51459b0992b8c11c621ca377791fbdcad73378a1109f0ab39ddf95c3e1bc25ee0ee67a8684d9bcdaaca56b2db8cd8861003f87c64d3c074634f2bf9fe835b3bef2b9935275c4e069de0fe1532d90fe84f24107fddc55b54f657140a543fdeef1dfd20596b8bc9b169d64884f042f76fed16171c9ee742e41ade5e14a69f23c05d396684c1e3122ccf480e331025416bda07d5b7bda087fe215d2db0393555fe804fd46e6c3e3e325245f6c47ad103f8adee079a4d910cfa3ce6b20a4ee816154e05740e983048b9abbd39a7d58b3d9507a4db06cfabee8bad2530031c744bad6163043747e16061a68cd5c281978ebf438edc9bcd27416d61e88d0e841820eb404292e6e80ac0f667ce61d68cef48a3e1137b6562e1aa5104dd9b2ab4b6ab5bd2666253bb43c8b157c42731efcdc1bd5b586b3a651c20be181a3a2dcf45397dc3a7072a804439c794bcc6fd273f1096fc406283bb321d37c6ea3523cbca53acbc8f935890e11d82f74b3fbab329bc252afc2dcdf85e9fefbb69a33cc3a2c8ac6961b212b376293990a9876053f81e7dc81484153dc89553e9553677f4c2b866e0515ea8f8b20493e88215ef7c6dd46d3e2279a45ab326dee01a21955c8c29d1e8ae4572b0076e12257ae9c0df62ac934a05fc2fe35c718cf38c8422f17ee1b43bf22df04c08da83d07f2c80ae041a9a61e2ea7682ba67a56321dd1436617d4d40efdd17b426f2dc31c80ca35db9fd11156ac62e2f64cc7f9418ec55911525aede82c2eb5ba578cd0bd10d4f1a221e7ec5c43cc516dee7e6e2e36870631670a147ac1d8a6f3be351afeba2ce2c681b605ffcab2247162daa7f848c58107d8317a2ffe86f65d8205b539fa2fb3e707e20c9b98d16bab9c0fcb07c068cf9e185265c16c842573c7a4d5e169fb432c5e66c72710ca3b70ff9e09d9eb8304ba91bd969cc14506ba4e3e682975147beadf9510b0892875c0e9a71356b580461adeb1ce4105813067c317c12aed28d4389e38beb50203f342d0f756ebcdcb5faa9b23f3dbbb9393ac71903699bfae42e69d6a824c5d737cb17c091b6a1d57a95b32c0a58d165d9ccc89345dd25cc4b9269fc163cfe1e184244580217cf378bfeb48a76513201023d795207b3820b4464f88d98a356f48dc53d832f74d49d38d2afba878c57181da42358ab199bb0a58ffb4532ce6817c64d4f846610625820382248e2147fd397d1c3b8f27c97bde19724cdf80755993448260d063026eca7916cd08b6080a8bfcf46f00016dbbf5b478501fe612190653e96a0e33f6cd5ea563fc8c8457e69ede11ed3f80db76879a4212cd3e7eea9256356d74d3e706e3593a102fc10b8059b8633dc8cecf9e299343197754fc77c7cfd4bbdf4eb5465433d09e508e10cf51f8e69fbcfc96c9e4c162691bbb1b9f799a89670905224a8b6375908bca3ce8a2b11866557897f50ab070fd621c3574bea7629e0a866c2c17ed449bde9254364d2f8f75c8f769e1353682ddb8afc0f1125dd1598b0cfb2f5440d44e848cd151a4a2e661ec17854b5eb80f496e3f2a6ecc726f9b91c8ac8b1babb23dc249f3ecef5b5c3c30791f69eaf4e5e5811e4cf18486db7b26d1216b9d2fd63581f93f141bce75aa99d49352abb1526ee18149380af784e89a0d8850c5061df2d1999ee850322166ec74a0157f29496d7f5d0eaf6700ff79f8e495c26f5f8a2e686bb255d0a57b5690df9eca396092b8646b983eb76b584281d478a99725dc131431ea364fc3a87a722da61e235f81746836939dc2df81091d9633539aa33ddc28320deab082e9224d863c6af661f301870028c760237b9a0de382a5faf0b9e23545e08ef45c5a3ed40d210ee6f3f05f458afd844b1622e888c30c007afec639c0919e1aa3538406b8ddd2e152261cc040f401e063d16d24dc58e0ee36178682c71f38bdd02806da4edb7772847e3c96bb57ade031e56353d74b57e3d6aac0a8885a3c89c84354cecb69b2f84ed71d100596cadfc4ee03378ddecaebcea32f020adc8ee6ab217f810188f727877a252b0c902fdd25ecf8603ce30ef235b350511a5698ae9e07a54bbd57396066dcfa4905863ce1ce777734f5d54a5e88689a28f48c28c03c23120b88cbf5fb962f1d1d5db08304cfaafaf6cee1ebbc4051549af2f3d4983bc11555668cd32812e2ae1179139a0fdff8016d98902d8ecd28b59b0523f017543c33927ea160e11f9190602a9f3952a37cc1b4f9915c388bd147fbf233d42350ed434888a66d19777abc896a57493a26e79661ec6f57b5a668af54f51d3b72b550b2f11ba635e7eb640e79a538e2c6135b093dc2e20274906c7801b8343bc139ef65f17ff0a0c9877957db36cc17eb52d20e0cf4a4bfdf9b20a6bcd45119af6c3501113a320336f9473d7be4d7668b079cfb6ceb2697194255b09e4c9661bc2149345c8c98b4acec43044ead0c3ccf4f14a72b839213b9a700faf500c85c5aede98136c3e301d85c1204c5d1bf3ee07299d33b3d41d9e8e6e3d77c9d804111ed7bf39553da1addf3ccfd6c7b7e4c5358969fe6edc2fffbeab8418cd1757c46fc494dcb8a4ef32b24a5860b9b2529ba83cdfcb06242afe2758ee55ffdb434dd6798d30b883285b1a0f04187cf806f0de03595c09a531116a3554c67396d9ecb327e262be57747dd303b31aba56becf9affce240348c21c918b069265915e7fcc1836689462f659d48ca55acb6dc39a49c31b5b09ad31cc10ef8b5c9b064c1786399f7ab16aea3fec44a628418cdbccc4158f5d49882020f5fc63d8c83b81bf825804fc4b1977072f4c74a64280527c63580c6861267bf5c035a25b672aaf40f8cec86e5ab326aee483044d1e135ba1254d0450f76740b0e2647f34257deb54359ab8f0b79239f7fe721f304530370564c26c66c3de56234cc6f1e036a54980f333bac0875407185866fe3a48b32f8bf196259dbfd0206d046f3ea01d7601038c01d24eba102574e0ca84cba9f3bfc9d2fc8e33ee6bf0258f490bb69d6fde6ff1bb78d0d6f2229656ef08b9ae5fb4417410c570f66a4b719985166d68dc086655389ee872ea1643de3dcbcecbae2b16b9eb471ae88327d47fc33ff65148102eebcc33229a0b6a026f7dd05559086e226521e537e29dbcfe697020df761735a321beb31d7251436097949d2f251b6becf7157e9cccedec605b8d48f32f0f427348df26baa93f9f9b7cf1f2a858c58fd337853b715c2cb6a2c77030ffdbbcbdb8ef40b515a6ff8c65d486d7c3ad2c2c53261526d8ea85cbe5ac8ba4e29c50fe2c5cdae8555cc618942f0e915c535929932ccb309718507309d02e40ea83d12a26f20498dd4033f047898ad96055747db559960d33470c36836b51515a35357fef1df5f996ef29b79e012871bae0961b40ff423e87d68e8a2c95a995c0ce4b73e270ae7ef098a3c8a1549d9e97065a47c43c0c27fcb7c98b3636fc4fc9e9dbcac87100c32412f8990095cc445c9d8ea18f18604610fde1055a6ac97a5910ca0a45fb62bc2ac91943bfa2057d2dd9b8bd4f64738f6eda08860d4924745ec13ceb674a4aedfb83409296ec0e6cb82f1030644cf13ba2f7a3feb61ca02ea2a28934456a9f30bf35c0b19510250a9b6e8cb3b841cd257fbbe768ed5af40877dfa829dd5df59e09049a94025cf15fe531e64195f7657e4f2e6ada01e7ba6ad3b6895fb1789ede0cbe9db1bdfdce0bb9c43e024b5ff0ef78a99b45d1b5f644f507dafa145e2c9d9c3781a3ffe14055af084f0e8a1ab326dc00c1e0b374fd03abb122e70d2651c5ba137041f554d82c42f8cf686337ae4f6cf957ce3d4aa58deb010dde28f15f19cb1759f5ae9976a668dc5919a3fae2bcd22bedcdd606a910b40304a900233790ba8e4d602ef52dc6a40ad97b4372b9a14456cbcc482ef508cb3723466380c0b11f27f4e68ad1190e093def42d05a254819f5380d01689af85d5f231fa58f8655336a0296439b8394394b7fc5cbcde680f909abcd0a46574e3eec40e4b83380467b3f8b2a95366183bbd71d8fd2a14d6e7d0538f1505501a6329383911a1b42966288bb3efa7affee08c942e491e2851a0ae77c9dbe6263d0d2b67bc6a85496d8119cc0ef6b7df3e4d79a1896c892ba59654bdb70159a7d0728e6c872ac3a1bcc9a8c8e23af48f40295427eb5288f354cb3cc4438b9ea1fb74ee5d1d991a61794a7cf410c11356d3a741c1959bcd722930448187553991c24196b0457c668b1d29d9cae68672255453c24e6d10600ce28c0591f5e13e6de72d543c33bff79387c2be1646964ec87b914d94b6b53acfeab074bf3103c854127356d879d84cc1e4f58c7336f529ec69c5f8fa7095f23a382c79f0eee96d60a43aff6f2f96ce36827b148a0ec51399c12d0783416e4202a07c935ddf0131e0d29be571ced3677b87d6843e06225755e17c61a3ce83eeeb1def83bf8a05da557b4fb68a9ca4bec9dce2776915eca91e98540c2d055aeb1dad396578a08fbf3e5129e85edbaf60dd885748e8f66cc58fbccc508ddf5bc415c71228541b210e90ff6628bf8f5e16859a0355805d1bff6dd4810bdb3cdbb16e860ffe2ab409c662dd683ce7ccdb32e38478d59f2609061a27443c399a5a44699acc82915668427ca9b18a0f82e75bc2359f7a800800b016d910e63a14d994ec1e9e0e4e5f1478d24c7a599b8dfd7fd39e1a1d6a619ccedaf1c861688dfd9ff460c2dce726daaba59960ba7f41bcfee87db8fdb626a92533bea1c793f793b14300dee8a127bb25b86744814c96e301b038bd35b2df7c170168afd075ec5145ab33c4ad89929f8a5a4a798d5a9f2ced8650474638194f5e704ed15d7fc019d126bb57f6dc82b8957cfa667b694ad6ef561609b556d1783ac78a9da47c9723836d7be105d6663c841907045edc0aa59f5166c890ed819e6796ba4a16f3ade368b82ef10f2ad37fe567603791eb44837fdf1f42726049667e6a1be980ebffd166924e6286fc516794522bf4e8966270558785fc608e77756bed3ef84f60fd9b74789bafe19ad585c1e0e8b9765c4e61ee6d94784013b946ec7a6684c7d2dd398b42e8a1c6fa2cd840daed0012f409d508ae379b4a73a96d38cb08046719f85073c195eec634a4e8c120900e2bcb6121bf6ba792773052d20ad2d0c5d7cdc955b0efb4f8d9e9991049ba7f0ed215d54f913c95024a2dc6b7f96194d901878e71bd5441c45107d570fd11058975d693bcf2ea45998e093a9108013c8aec64ada7b92d247e1c5e8d62717def6a32ee5f01dc93590186e9993953f0ccdbed5fa4ef2830bfbefda5091f1208df228c3f34a9d6ded3d243fc417da2f80e581fafd7e958f078c6a3ccd0d3afb3322adab5c839578c1a43a3e8c5f23561dfd345c0e6e9a7132cae6c94c1bb34440e000e3bcb2d1dc4d96adbc0716a8aa66741b770e609613bb4c7a215b2c440dd7fd7a52e160e782574896b83a032523ceb87c11d1a93ae8ef87701ae16d0967df4d29df100d7dcf46b300ce43c3e11cb64338a586c449389b499e7ee1f28d23ad191cd12d507ec012c32ee05f6a4d42fc903cef739e11a9314fa68cf2e8605856968ffbc21e0359572c54107a844faef8bffa3fe8fa4a34a20b52ea558107a782addb2a9097902aa46723569789a8a151eb762c7fb1b8919d65b8f1e684fdc5e25e9e7f2a3fd75d7c4afe23330acf6366c76650c5892b37552d4fc0470029ef2fc1f1d65cf8c5819b5870e0ff03ac70cd6720d2a8e626a0f9200a697d15a36e90a1cb5f95e17c7e1d2cc520bd28ae8414d4e6dd94bec5fc8a240fb8bb806cbefe11a0c14bdad8b6ce1afdfd4b656a8dcb528a89480fd5480db50d6fd2bdf141d0eeb273910b59f23a6d10025259ba52ca0d57bb8fbe8dfc5b31fa4ef7ee130a12efe2a38a54c9870eb07787496b7c223c1bc485ac491d5eaafcc090e2dd0d0baebc289c693f457506953a80e8147cfd1384fe640c500250f4eb24684f0c02dbe37da735d0218c1455744377c1645eb491cddecc444f6325574e409a93b64368518c194fba601e7a5b3c734b9deb6ffcc7ef2e1a95fe1af407282e7f4115b4158d6209155a865a4df73bb298db30fbec41143510332bccc9815a125b0d91b98b138976d0a1651ae731cc6fa074a1660fd1d591f7b125c8c985a13d8c0819dc428160f19ff41b4af92db618e10835f277869b02175e91a9bb0d6c17fdbcd092a827b469354e3b8178096f1026d3be35cd7a10d9ea82e9fdce439ae2e3e3308440f434f8f3ddf6aca76bdbdf9dc338920b9e837664c32dd0f2d707b4d6f9702fe2881a6bcd99a5081482211b040844882507619dd72d42af05083899ec50956559bd7a2032dfdefa952e82562b558dae5b4234cd9af4017f394a64d598737da803fd494d0817542007afd73cddb757e9871243b279ba5b2d3785ac67016f3a4693245c5b44d4cf645eee095b0e4b06926103bd487400e293e0692ea6997895e6ddcd19f0e8a6a2022f55e7b35a38f2e3fdc174d6cee0c92484feec39d07f08d207faddb0d7967e444ceb1ec4365f73610e2f8c5d2c49fbde95e4f626d92f104f5b107d5ed72d71247d26059433cbd58b56a2e81a6a205ce206a06ed94592ce45bc935561d1f79cf38741d9673f32bfcb7554ff7441697ea1f8e911c709d10f16dfa0f2e3350b7173f7af42555a67f65b30b68ce98f771082fa50c88df31a0db70ddc9405c704b3e833a5784dba707f9c85ec1f6d739d346c647b8c988abcc9888f0fb500a9cbec3d97f4b072777c752b956a38c04f94e190a8cf09208f751fb5901361bbab6709f698235869132b0d0a848e30ebfb377ab10af456faf487d443a5af6c79b328c169f8dd5fbd18ca3e17f0ea538c1c799bcb9383c0997fff5fa540e8d24f932156d933794018c959285a6a0cd8445026c8a97ad05fd9556ef6a600c4bb3cc3958847799c15336e7263479023472a3949cf88320c81599e088ec911a4d994b62c24b546cc3f7e538e6a33256fa8e154e19863784fbb04e2bc178cd39247c793148ba1722fbec2fe2b4ca6709a2ae7a431424f257e72d175e8c44e6232b1953ab95fc183ee018015d53e505f1efb015c70cd68e9effc65978b5b0ad28dfed1fed7de238cab9c7775970a3781a714fe32287e768aef7031f6a614fe43adaf8953ec1745bf4f753029f3fbce3c15e55d57529ca92e227ca67079eb3cd5076a4d23158b7ba23a708605a6290880285e35e7c74d3665427d82037af7276b9b349e6d34743fbe03f4bd2e2a34b8c796010d89e9c9a06f03ba4d7b40497c75003ed70f2d0dbf929e85a96d8eb14c54d6c81eeea4a389a18d822b8795610402288951dbadcdf1f20b220a5016e5154c6dd8a7e51d8178058fcda1a253c5f22ac515cbf7b507343fbed5ea11ef13c7b3b2a3ffdd4f99254b9074b72b13bf2df72b9d7a901d9464cd3f95d795f7dc6e2950b783292cef518b136f175a6da6425b7399f262c327b8221ca86025f3bfda0d819c82f7399fa0e548546adc8975770aabfa66cb2de905640304d7ca4417ddf0d7f3b63b2bf2b2eb8d7ed54b955438ca055ea65ede834cedb5e3f07e5e68f33e9df7ecce5f695c32296df199433d4bcce7123266e9955e9fc30c0d31a5025a82b7d753879e9315f85fe7eff2a2a0735ca793a3c15dbb1613019da6c9345e24d910cf65568ea0919bfdcde9644f0ba83d736067bbd41fa3be2d24fd3425a66d51f2b66b2debe8394aa3ee1a61eb8fcf9f252fdfaf9a3badb46e26a3226eb16db704d8590c70c9e3c45cb4842505092071427cc487ec4b73918b19d448fe871bccd6863b79ea9dc61db5ccd4bf73a7c7299204ca404a49178a3a3f0433df46721cd46bc75cbcae788da339fb723fc3bf6e90c7adcd2b4494d848bbfc3a94c4a7f8154c04ef76760d55d2475fbe91188d34b07e7ee7298070117215908c9a08f0c9313367bbfed269f53bd16a0d2eaf3c616f92ff6eb4518535e501f4fb8798ef4f88983537793e48f5c4fc658450c6fff3b12aacfc2375bed69af961bb15a97345cb5de7bddc2c3d8e1eb29d6bfa7b6a5ba0b5a8c2f7c029eb4afa077d3dde49fc87343adda5f6dc4b4681791ebf1b2462b95da2ccf18e6805c8f9df98a5f4185d015873c4f5fa6db0cb4df0e50754abdbd64c1d0b3d61d4e9f7962c2e77040c31d5d58218237816e5e8d52352ecc2a2da55b509bc0bbfb0e57fa66804ae61b06c0a5761df4d934ee9bd2bdd9c2a2165fb8d3f71eecd9ad96a1fea7f28c6c229cb122abfe8d2720989d3cce257101a5d60ecad235cdc1bd4d58be0a102ec4c6036105df5dc9155fadb6588ca34536b09e0f406b1136abde36d8f5ab0f7f4b037dd892cb826798965cb0d80924cba33d05b5f786fc2478f01d340a7b5c270463ec644724192486be1a863fc327115c76e8bfc0ff7ebae42727d4b851fa2d54120d854bc304cac142ae81e4cd5912376d94620f3c0a89cba1fb84ca6c9d65749fee76f47b0885457c2f68620f4e3321ac4f01ed496a367a881716ba89d76f3cafd7170c22b706ea49d50a25c9fe67af62019d3021e5489ef7f61fbed7fe36dd02b0d2e13588f7a9f43e698a70fc92f732988babd8b6cca0bbb421dcc0c610fe49a0edbaccfc5dedab8f52c38ec24d487dc9f98c6212f579185a5bcc30924a571c510eea812d1f2e6c5f4fffb20299462528e26aebe831529beffc0e76c4fa93a3baf56a5b5f5b4aa975bc09b5659cf9b8a21ae088b67a18d339795efc4b8575665b88c898e2507d2ce0e87d5eefc2f6c5fcf700148f1ade1745d926c2009c9083c81a39da47d2ccc46c65b28fcae8b03b340d0376f154b2a8b74bb286c98f6fe63e61f06a6f532cb1984a845eaaa2e764ab6b5ed7331cab3f8346286a16a893c84f9e3c448f31cd9b4d1628dbd990da7c134363216e86ba0ed71eace993c390cec42ac54dfd86243d0813e3d364a92453cb5d88817d0e31996d1880e8c296ee5da2083f7a37389f2f0631b4119ae143bcce75ea7d1f6b17e088ed69c9f8a9fec559d76397f504ce504b8eea36ed5c2ee413467ea02f0dd4c39fb02c2b00be8d539da7c217173c563ed6a7f98a1123e170998ef590edd12211c0617913d1d5e5c7455f2f175e5e917ca841229dcaa366f8ed41a2658c1c176905ed7e2ca9da99178fe3e2d09313e23c8bb2859c567b57eb43c6ea4bf814229dac7682771d855fd33af22f3b004b0a36023300de7a9af851887f2916df85ec88fd13a5541e343b12bee82b034b846ed101a4fda98df78a4a87159a8be8a08ffa5ec2dec03bfa21b684caaff08695fc55b3ff07cdeb6f37f9a62124ea9a9986ac397be10cd3d7d186f83108f98d8af4889a70d8caeedb644903d2d380868ae001fa75e671a8918897ecf6d301181dc9e38e7410cbee95bf22a11fa43166e4e03f04fe914c1a79e7dc0f765230b3c515a8246e575020d152a1e9acfa1eea06c17c8eacce79e20f422ab7e115ce503557f040bc2095a2f6ad41a8bdb7390f78cd3842469b6932cd9bee8bd00b45b436110f0f5c55f1e6dd491d8ee42e87a178ba2eadef721d7b965d8874e1f6f732c266e2544a46ee84a97104173cb5ebb9714a34cf3f1b3d99e330907b6302006cfbbfcad184b6a3df21269f4ecebd0b30f733cee0837f9ba80d71ff4cbf238100fdc775a14cf4ac0d7bf788d0086ffffd7d136caf13f1d21ba5187a7e4d1779b9f7fbf382ad26b251f6a99d0f9b4f00c16c79259e5a1826467f9a7fd581399e20c58fe4d1d688600a23e30fb9e50140606e16b0d53259965e6521d78d714fe4910f53c7ce7a5bfbe2a906876679acb0f74d8f85fd6a0f7ea0d6e21da60b481f685b7ae2bb8a580db06a81d13c77a60b5d8b56857fe5d3121f9943fbd03d2192f01d8a8d271c830fc652261d03d53ee00b5532ade36a64b0469960526ed35ca14d1e4ef34beebaeec259d579f9586c1e19ff1c9e9530b61b42079427f9d943e8059332c57192c62ffa826b9fe2a258f51d59190e5a5e750b4f6e6f6205574659061a1db866cfbe266e9d0ecf00aa84f80362ba0ea2f865f7361b3a5594f8d7c658359e5c94270d0114de0c0e486841054f6b48cfafc14c315a554a6d78bf9b1df1f4e8fa434a4a08c013764dac00e46ed0aede957f36b4922a766a3c110a7d220bfbe34edf37907ba959ef22145391bc0c5a543294d07f0df4ee73891b29f296ff69481f1ee866b8202b9f04323e18217a9f03a903672bea8e399c14d95b95afbfbd350a8132504d26b57f09a11d4cefd1d9ee2cd82893b4aff05a008e1045fb54b8076f1a64ef9d15fba4050e54e3e692a58b7d668da7dea1d7400d86cfb11e9a61c9ff6e164d007a6d8d33a2754b199acc7e024b2944bd2bcb4325861fa99ae1e0f7c511b67c39c49a4505c266ae27ac27c95c1f29550cee6b99617973391c6892251c51df79a815800fc2b9a5f95ed79fae43ed9c76df44675386e0e4462583910e5a3e581aa1ee96314e240975377f7bbe489709893b5ea11d9ce921e830a1138d5268eba4d323a32d6b272e3fe4bdd553b3e7da281fd54dca36add952e2039a9692be2301602f9d7462a7df43531bcb846ae849dfbcd2715b30dc020c3e7ec2b6988328cb9c5d952f9fa1d671d5e179885f138a28361320e405efebd284af65005c24aa80bb7971dba6098eed6e7cb88a92ecba102628d541622a27fe9948de94b5f04ca2b0f09c34a2068916515211cae3e88d5710a2f191d8e938ef83c91dad3200ddb46f4f2fbb234ed48c7b0cdc0b209d81bc4fa45166760f628fe8d1f01488991b3875e6ee098bd108567bd4ae9575d0c62e27685bc2bf69bd1ea1081c56cb0e6ce71071455ed7df8a6e6a20485c32d45a30a04b94437631059017ef0236013a810663efaa6e4023ad827e08540575c72d0cdff939198ee8ed44d760361c3742e820919c2988a453288796688b69bcd26bf44ee44c8b60d0dadf4cfc15f44e948fa4aae559f0e12f9e224e43e08c8051baf18d5312894a006029f7b287e3ec80217f133925c48ed0fa1ac8f089cc862c4c7014747679f87f1596ed86707c0cb63270a73dd57f7d1beef2ec357c9ff024572ad8f2e9e5f722073d442f8598dc00a5ac62571a33bc9be33b1d7ac960786d9ebb79748c5edb2ddf75b272fd1ace683006f96977846dc26ff736253af9d9fb95634f3f341cc65eef02070f778d58252dfb5db1b6854daa79281aa70ed6ff68d17c25b6aeb837cdbc36885ecf54c2437c7a356fe8149130509207a809b4247f30a809ec1561906ab02cef801801fd6508d17a81273820f43edb310a159575d20b70ac1ff4928cf6737c9e0d3fe5b1a00128b5c1278e5c5ef634c27ef6036eb573dfead9b9563bf4b6189cca18a1dc85ab26e8b5c2e0bce5e20734c5e18ec8a0aafa8e3ff8a5b7c95f0df45afd4a7a99164fae40499f170fee1b72ee73dc497c94f4f6cb904b5d17beb9252cca15040bae173dcec41c40f1c0d4d6e8fb84c46941f6f7854777cbb05b63a782b92bf1e0195c7758391819b6d1bdd67a83b9ba0f61c060af339a2b381afb4dec542576a1156530caf05320fdec20c2d399446958a1e5859df328487cc16bff15b96f53b2510c3569d93c4de5905cac96c3bd12952bdff95449987ee1c34336fcbf1dfba82fc7165186f095aa5f7c00131f0e2588760847aab781610665ddb93ca4da034a439d74d0f434ee1b4c9e53261c0b23e2b91edde95e5a946ba11b232c5831e6245e03e95d2a488c8a41a2f6c1ab2e1bb5f69e1754709cade8e704cd5155d1096d32de87089c3c0753e74621f16466a06e7463ef673c4fb4f4288b74ac95060409d928b9548b5f7d2c9311326d178bd719497bc404a9f8d154e8dc64b417f641d81d6425ead4a1fc7247029a44619a15e4088370ee6d21d90efe9623d4f772fdde0588092703a3a9b162f655532c1b04eefae9a324ed2ef4fc2bc41f88e5c90d9233dea9ea49f6ea24761903b448f5c85750673fbd4796585d7eb19c014ddbee62b6544625fac4affc02aa8aa393d70b3a5eec83e0dc63eaaa112b7ca77b38e74aba90faaeeb929a818cc0324e0617764362aac7ecf83192d2ef97d178387023292f708b2f7d8ade55dec271544b7a761150e0f86108d9436bf49572bcbbacdea0c2d6773f9dea95b4c7296b80dd8c05a13b6662d3fcf18428e71c6e223ea98bbd20e4af1749d20c6dd437c89d1ff24fc191185d74b69631d868de61d459dd4e824fe22fe775d3ec982ec0d9a1851b800d52b604b806c189b629eec9c95fc7ed5935020fb17fc3c3f6a3c263ca878fa3942eb293f5d852aabba01132a0b4c62cbcde947610e9d1bf715b606bdd4635aa69b0002a5a9bb598b1960680722a95571d121c113e640cfc3ac0ca7e1a0ca5df5ffaa1de61c28d050d5a62dc1627d420efd4d922dbae0159eca61b3875d1db6e9a49216421336becd0a313442234dcf4d7d9041371a4c361adae8ccc1d07a807da3de3bdc400ab4146e38d7e6caa713c25acf5a82cd1e66868772415e67810e2edf8403db14bc902d8ee6ff4647cf75408f0379c0f2f3faa32b5d3949fbda855dcf017ad23093902daf975a1e8749f8496f88a2912f8f50e1b34b3359fe244ef79f86fe9413cdd716ce5a66df48f31667b8e17210aeb9b532c5d1b625234fab6ba1b26ec6c9c88d4fdaedb39a0d776d0fc98ecd0fa0d98eddc018a110ce64e1c1d9582624aae58ed3ce75f258bcfcd0d50fa98c6408d2463be05475ddb16566c63bc8b8da87a32b589ad39b071089b02bab667a5b64bfddb18334e4ae3e5be1a66c4c70c63193284977ee15ce0effb37c35c11d80110f1f4fea3d63f64f4dd651a6a7f6fdf6ce6a93368745935bc1256e98b3844316e2885bb8980a4ca85fb994ee8d18b2619f3682555b087b880f3088b7affbebd53ffd559ac97a03b5e90cf0ffc0ac7c8a9c2ea10ffa6f669da12791490a3cac8de8d4af35457717eaa3bc82999cabe6c591ebbb22ff607a9d41c3e06a8ce57447dd4b5bcb8acd00a0dbe63529d87b22c9f64b8d5692defdb29a41ab28f0cecce3d9b484aab742715b7f9d6b508173c64ceb79a42a4b76d2943969f6a6b619b4ab4ba743638e2564bbc6d419e662a1e4f017bf3181a4343659b5212ff037be8531760729e79fb0019c097add9092a6f5a6124d3788d7c3517e36bf0c62aa4d05befaea9a089b82b3e3eb27a4b50af40731cd182697c7b035fca85d4e759645db37b945483c9c69c38b55239efed0a594dd7c809c49431762c50e333d79a1c54c29bf169f30d56edad38e68cfeae7c7092ec317ed074b71d221c1c686f7af5c5a8373b9fbe60ad9f2a33e6568eaa156d18c7dc7ab0c3f6435da5ac7278c3e401ee9a953fae18129c460150f50fbf7b6206aae0d2c3cd9e3de67f9d871cfea11db7e9f1de73e4492b03877ee98ce04eda3e8406e721f5a37df93988d340c930bd5c8ba60679dbf02802c23a2a2c52b36289b270ffc0b7ceb339aff553dba85e49d1c58cdf0114464bf45c439523917ecfc1deed608cb34e32872635886e775e63b6213d2f7c16bae561b141906fdc87b143bf955a6cd5873c7793232e807d1950f9e6b322346a4985c27487a73c497a6a07a2d820cbb98172c089a3f0adcd2332baf6475a1bbf0bec68847d9a661b72ffcc0c829b5bcdbba949e2cd239255d224f7d9cfd142ae7f577a6a3aaa06a4bf448996e07d91b5aae3d551e4e02a24e86033e5ae5bd184e482113a1d49e190735c914a2f739c56d3b0641fe8193844a36c3336edc71c14225b2655aea233d9d22b7461ab5703c77a8f251bbec64606e3be13bb9190939261b29ac57832f460d0bfb5fd1fcc03a26998a737e0e646ed5fae0336d17b39312e700755ac67b4c61834a9e394ce7dc2e017412401d6c9449c44ae24ef261d9cb3b12ea1ca5059c0d0cb8db45775030f0eacdf3dc281142aaad7f61cf350ed1e673a9724753451cef186be647db7dae1a1e1d32c76cbc1755af702dd04a5d7a097398872049e857c9c7750e7070313b99eb7eb931fb7c8a284a44c9665e22be2b37025c9f75c4a710f20f39cd1339644c68f3a4cbc3c787776f297b6fff51597f8b981cc95eb41eb237a71fc72eab48a16ac8ad44b0a7942c6277a016da4a2521c2058d801c8554dd966478d0971ba3ea385daf9d820f556cd5ad94b116c19f4073b524df6e99e410ecf09282f50e4dbb1f3587cc560a82c819963787810bde9614a19a04d1fe0b28fd3f897fbf16d1944920214a2b75cb46575c710bb90b079bc5f4e9c1c58525f71d4b975a292163234f102ebcb4c335dd1ad54784cf637c06387efb7bfe8648912bcb04334fc22f75cb7f7eec358e2cc0f70d2ddc2c29e10de4c39c6128117efd0a1d256b3b101b25c7e51b6e93719e9551e67ab8b919ad4bfe3bec4b39510e8d554a59a24456d17a2b64ed862757b65a16f0117414c372e6b59637094920e7833b34b65eedd069be7dd2983c1aa24a88f0325d71a71727a616c69536b038de4ad964f090dbb3ed13e327cbe923ee9f003aafebe98577d2b167ebfd07ef70142a8222d4fc1d2c0d32caac107d1082cc6814f034c0122c7ea376495b66754dff81878cbb9ea95f8092caa0dd5414049f9814271e5055155deb0612855548527a08b5f0edd21fce7f4384004b592b9cb04b3ef182029fff35f1f08b3a052f3c7bb06339b65e024dd958fff565306f6da8cdbdd26d5f19f3b740b43d4b9a30a2dc3521576f911ada4934f34d2591b20f011bd312eff6f4c61c749462af99179be531e92a8935a32018c42a2898b20a39a158cc957addd57338abe1597dd89cabc5895467f5c091ee77986ed5e3df3e6462d29fd8e76eacfbaabea520aeae24dbf898c5934cb79b389a937b275f6057bfaeb9dc2f92f1260d605c69b3ef0c064e6acd8046d1f6f90e69ae08ecd8877963e50e41db3a2c559d393f087480699c3a72865e7bd5f5bd6e67f56252660adf6078a0728c4f7b12ee580e8099364e2c08257e6a4c8719db22686269784c7b47729c8ce9f93b1f03d47e2e137ae1188f8d4981977d60ea925e048d2bfa1eddee362fcb3ea25c5bb912ced0e87299897e50a79cf5f88e5426ccf3cb6096cdb5a02924b4033aefd82a18609a00fadec68d7153eac5b3facb6249ad0d977aca859c0e4982cce51d1e8f19935f7160b1483783cb25b51fad0cb12564d88cdafaf1108ad8447f391854cf51955387c0129d886db1da0c6d9f99b114f2bea73a8a0c1f105b56cb6953d86fb2da9db10c10059686e21e203b7ca859a52389801e77d863b6b92a9e60e715858fac815a5c7c3fb78b088083f705db39de4989c6fa9d155163dae3fa666c9696fd977aff9fa2ea9e93cabc130c71619fc58af394dbb25914204718a19971a60815c47d6461134b9c975bf52961270c5ac216afd266d84e0bcfabe024fbbb7a6867985fe6c6b82be10409f8d430e8f435ca87c5fb7478947a6e5251545bf5344c5d409a27764385449f8a1300e9714018a37b6a6edc9ed94a835c80bf8ee5cb5f7ff7cdee3ca3cbc27c6bb9d5f6632a8e16fe7d825f6a1a0429be74b017bfcce2e77f7c251ca3713cdb4d043b835dace740242670959523d906b13d5d3d92ead450e57fbbb2e6463515e85ff0996a6b623b0bd5905722c1c77aa35b6316c4d5109610b9c165d3286d845c64861f58a0f7cece88b9ede9c2d6262c25f82bf33f421b312463e7ae29f6804e7d4a18ad2fdff9c752d3d8f17cb323298a1758e9b0f0ce4792b94d6b960d1a8e40aef65866785274f536aad6f55d064f0e97cc41c7edbccb8ede3415f2b5d9758640385aae2eca896e26a01d784de9e51485232819f56c0ddd172a261f279fe2bc2c8b6e751be65f1e40bd656e561d482a3e37b568896ea362840463a734f08d07cf5047382511dff48db075577f2333f5cba6e50d12f3504eae587634a22f5daeb3498694e66982c6e574670c3ba10a547a1075561ce791becc1d6a10ffef2bda1fb66c53914286784bd50170485ab710e13738772ea2e7ed9a480ff604a6ada95da439389f96445ef366db8eb2d56cc03a1ff190a16d99ac70aacfa5d62031aa46d8f994980acaa08936d8e77f0398ee78291a2d7a97199e22080c2f44f6501792fcd5930810143834c6962748e6693661364035b51f888f4a6d7396fd65e8cbe5ae21d259d7e68a6813fdd182a242ef094d30ef44b085add70ad2ccc7064fc52db6e969513ee7a02d48d4bae786e8d57b11c7933ceb3dfb32da22d9255087c24f573fd89aa5eb5f7373c31aeabb5a9d3079b3f57012d1b3e73e87f6d71a609d40e075612ee7fbf72ccf5a1a8f0f7222f264e0c1f477d087b790e8dd2ae4a12801eae935d8e5af5a90f3c6567d9576d4d88ebb823527d4afebbf352bec7a95adeacc7df5e25ad9bdd2d298331aaf8c1ad1483cf3868c12db53281d35bfed8278f9cec99257888fe54b995e6c76ada7938b48ad7e0d21aa56df6aab6b597c0c3df497ededa06683298842db02818b3d1e20d608d48e49fede01bd1e07186af85757ed5d9b53a708c3049c55e00ca5d79f06ba50003aae661b6d4916d3da4dacc38676a8dc8f1573e3239f2c41ee91403e38b9774340a744971a6416919229ab0ca0d1c96beb12db880b7537553692cfdbdbda3660168d269024d30589218cb9b3c584ef5ecd07839f3a66b28d5aeaf58fca6bae0977b3b548da81509e68337d9f93d497f941607a4b0e697b97c3a39eb4782c1806b484c41b928d5b323ae12377bc541615b98104443338071bc4be0803b91882f918c276c81b190cde52013c8150d3ac7e1b3764c1d1665e5c324ef814fb51cc386ade1915ecc9d0e7c7d0b3bb1ba3642ab774f9acb274f9c6c4441c4cde4eb26af36e08a8e54dd196fd82f3b83d2b9ed70399baa297fd5ab13ffe16e784464d0ef4c2c2fe368ec89f3285b693ee8efafc677e1b928d8cc699feff9ffd9ae485c50b38fa1ea33906bf0942216c59a66387afa8d2ba7ee64c078b74c058b4186af0cd156f2b2b75f7ffe50d760cb7c25c0ae80a3351e568b7a1320fe0b5709905f491fd68078e007ebe0a36754a7d4093d90f4cc3ce22b04b821049c41f401fe858e2e0c10f42ef62fafcf578b55a8ae565359b841d5d67be1fd3ec9c838d1c7ae0b69e2a0fb53a1a55387c251458964fa5745d2c53f02c3e985d1ba300385df9e9dfa66ab69f059347f9cb1b96e784ea316f43c9d5dff7187a5dc97663f3b4a993c1e5bab923440bd7a263703fda3799a71e2d313d5f6bec3e116cdd74f4b8ec50910a67ac4258688ceb47905ed90f11a8682bc54fb13be2254d452497c5af16def7c42f97a4c302857d54c05161fbb55cd603eb765d9fcd4b3c518889cb2e284dfff087233fc1429d9b2106220ce9b03320c80fb4ea9ea46aae5d0f27916576b64b2e895d05c3840913fbad7f844a014ae4983924e08edc9ff4dd43559431b5333256961c91b64c38797ad4ec4f95216e91bbfd20c7c19a04bc0bf4a5d6f9235fc4ff330035c88e8a01db3bc9e4894d1fbca998e45bb04685f337f1886221d4d06682ab4945e8a923c6fb78615e33751d8c2176a1601cb2f013c4ffebc14ab22a1c67929a309b7b25f7eb39bf2a9e6f1e84fb839dc23d799db37ace8344dee0bf3af4b8a37e7ac81203094191b4dcaf3638ed31bec2090c0220cadc4ed4cd8bcd7f72a2d6032ed0c929cfb9f03f5139dd4e98a14049bb795f9d2390bcff74fd1f61ee67cd7da9f8441faa791ea4219dabd51fcc0f2d63a9ccdb6672ca228b2d4cfb5f40f4e73161691bf652c5cdcf39a9c38a39ab4b1c84bfb471e983651f2d735735520aaf5d27ed6cb20cad4ebea4fd215831e3aec2e2005410b6fdfc767c7bd740117dc390d82a2d46e252ea8877f99fe8e423dbe0da71095ab15935c07fe8daab737f7736703b9398819d1388ae21f1a655a11b93eaed35975b0e8d5c242d556c424483d38d1161c128d8a2ce23a63eb43391f40f19ed8d5dc3ca98b3f19de9c73f4c6d3d00151a389b76ba09203141684dd76f6a2f29faac4da9a85ec5993bda84a939004a28c35582d7a85fd3b32742ffa05d975f8f50c6d491af47dd1b802f20ee1a557c517810347ece3ed82ca5dd860e66f0f14614ad65d27cd02797ee4dd705746262f2ca28373ba403a1d04f243195133da136e18144dc241263a058ebaeb9bfe98b2ed32f0998265b86c823fe360a36062938c10ba447a0debd78029375b149a20d39e16c48836b8793fc8eddaa072030913f2c2a9fff02354eb884d3fd1c0708c6af977de4b4493d6ff66f82e1c0f6e914968d1b25af467195280400c667f201a7c1bb6aa7173aecae364dbb046f5954592e2bbaae710f98ba9e8742f8320180fb5b3db45f14ae13d2788fffd73d041f57360a0fe5d4fecd2bf34d575e5410c04e70e9c589d75d72634bd6d7f4e39032d4a68826a83bed67406e37ec45e6f322f1b287dff281298a81fb15c4532b746c8a5fbfaccbe5359e09467ca10ca7fc8737c8d23a98d5787b8de5e6245e3f8a0f7d824a38d2101ffe17a6da563958c65c3ad3d26b38443ac756c2dcf1b567b3805bbb7943eaa54271518a14b21e0ec5a02ea4119431ac1c5c1e02b596091986139b6867f8819d2bf49462705dfbcbca1f0d657545397c2516d25d0994bc17a373c39e6d3863fc8d158a8fe3ea1df477831cd6c674a967575ee4e20805e25abb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
  </entry>
  <entry>
    <title>Java和算法</title>
    <url>/2023/05/04/20230504/</url>
    <content><![CDATA[<h1 id="纯试手写第一篇文章"><a href="#纯试手写第一篇文章" class="headerlink" title="纯试手写第一篇文章"></a>纯试手写第一篇文章</h1><span id="more"></span>

<h3 id="上午写java实验——内部类和自定义类实验"><a href="#上午写java实验——内部类和自定义类实验" class="headerlink" title="上午写java实验——内部类和自定义类实验"></a>上午写java实验——内部类和自定义类实验</h3><p>注意到了一个细节，try范围内的代码是只要有异常抛出，就不会执行下去了，直接跳转到catch，后面也不会跳回去，除非有while循环，才可以循环执行try范围内的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reald = Double.parseDouble(real);</span><br><span class="line">    virtuald = Double.parseDouble(virtual);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;格式不对，请重新输入:&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码如果 real 转换成 reald ，那么直接跳转到第一个 catch ，之后的 virtual 转换成 virtuald 和  break 不会发生。</p>
<p>如果需要无条件执行一些代码，则需要使用关键字 finally。例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reald = Double.parseDouble(real);</span><br><span class="line">    virtuald = Double.parseDouble(virtual);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;格式不对，请重新输入:&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码若输入 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ff</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>即将 ff 和 1 转型为 double 类型，显然，ff 不能转型为 double 类型，因此捕获异常，直接跳转到第 6 行，其中第 4 行的 break 并不会执行，但是第 10 行的 println 确执行了。</p>
<h6 id="finally-关键字只有在退出虚拟机的时候才会被中断，否则不会中断。"><a href="#finally-关键字只有在退出虚拟机的时候才会被中断，否则不会中断。" class="headerlink" title="finally 关键字只有在退出虚拟机的时候才会被中断，否则不会中断。"></a>finally 关键字只有在退出虚拟机的时候才会被中断，否则不会中断。</h6><p>执行代码结果如下图</p>
<p><img src="/2023/05/04/20230504/20230504_01.jpg" alt="20230504_01"></p>
<h3 id="算法设计与分析作业-3"><a href="#算法设计与分析作业-3" class="headerlink" title="算法设计与分析作业  3"></a>算法设计与分析作业  3</h3><p>晚上写了一下 算法设计与分析作业 3</p>
<p>求最长不下降序列的代码</p>
<p>例如：</p>
<p>在以下数组中，求最长不下降序列。其结果就是  1，2，6，9</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">9</span>，<span class="number">-9</span>，<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果只有一个数字，那么最长不下降序列就是它本身，即记第一个元素为1（即在dp数组的对应位置中记为1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果接下来的元素值比前一个元素大，且dp值小于或等于前一个元素的dp值+1，那么这个元素的dp值+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//因为2&gt;1且2的dp值（也就是1）等于1的dp值，所以2的dp值可以+1</span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//以此类推</span></span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//第三个数字是6，</span></span><br><span class="line">dp[<span class="number">4</span>] = <span class="number">3</span>;<span class="comment">//因为6&lt;4,只能从2的dp上+1</span></span><br><span class="line">dp[<span class="number">5</span>] = <span class="number">4</span>;<span class="comment">//不论从6的dp值算还是从4的dp值算，都是4</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure>

<p>具体代码实现如下（cout出来的只是一个数字，可以修改，但是核心思想相同）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dp[MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[j] &amp;&amp; (dp[j] + <span class="number">1</span>) &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
